#!/bin/bash

#    _               _              _ _                     
#   | |__   __ _ ___| |__      __ _| (_) __ _ ___  ___  ___ 
#   | '_ \ / _` / __| '_ \    / _` | | |/ _` / __|/ _ \/ __|
#  _| |_) | (_| \__ \ | | |  | (_| | | | (_| \__ \  __/\__ \
# (_)_.__/ \__,_|___/_| |_|   \__,_|_|_|\__,_|___/\___||___/
#


########
# LESS #
########

# Runs less with: 
# 	* ignore case when searching, 
#	* do not ring a bell,
#	* do not mark empty lines with ~, 
#	* format prompt as "<page-number>/<all-pages> <filename>",
#	* set tabs to 4 spaces.
alias le='less --ignore-case --QUIET --tilde -P"%db/%D %f" --tabs=4'

# Opens cat or less, depending on number of lines in file or
# input.
catOrLess() {
	if [[ "$#" -gt 0 ]]; then
		noOfLines=$(cat "$1" 2>/dev/null \
			| fold -w"$COLUMNS" \
			| wc -l)
		if [[ "$LINES" -gt "$noOfLines" ]]; then
			cat "$1"
		else
			le "$1" 2>/dev/null 
		fi
	else
		input=$(cat)
		noOfLines=$(echo "$input" | fold -w"$COLUMNS" | wc -l)
		if [[ "$LINES" -gt "$noOfLines" ]]; then
			echo "$input" | cat	
		else
			echo "$input" | le 2>/dev/null 
		fi
	fi
}
alias m='catOrLess'

# Open cat or less +G (starts at the end of file), depending on
# no of lines of file or input.
catOrLessG() {
	if [[ "$#" -gt 0 ]]; then
		noOfLines=$(cat "$1" 2>/dev/null \
			| fold -w"$COLUMNS" \
			| wc -l)
		if [[ "$LINES" -gt "$noOfLines" ]]; then
			cat "$1"	
		else
			cat "$1" | le +G 2>/dev/null
		fi
	else
		input=$(cat)
		noOfLines=$(echo "$input" | fold -w"$COLUMNS" | wc -l)
		if [[ "$LINES" -gt "$noOfLines" ]]; then
			echo "$input" | cat	
		else
			echo "$input" | le +G 2>/dev/null
		fi
	fi
}


######
# LS #
######

# All other ls aliases end up calling this one. It runs ls with:
#	* append indicator, 
#	* sort alphabetically by extension, 
#	* list by columns, 
#	* use color when stdout is connected to terminal, 
#	* group directories before files.
lsUniversal() {
	ls --classify -X -C --color=auto --group-directories-first "$@"
}

# Calls lsUniversal with: 
#	* set width to screen width or 69, whichever is smaller.
lsShortCat() {
	width=$(widthLimit=69; if [[ "$COLUMNS" -lt "$widthLimit" ]]; then echo "$COLUMNS"; else echo "$widthLimit"; fi)
	lsUniversal --width="$width" "$@"
}

# Calls lsUniversal with: 
#	* use long listing format, 
#	* do not print groups,
# 	* do not list owner, 
#	* print sizes in human readable format, 
#	* print date as: '<month-by-word>, <day-of-month>, <year>,
#	<hour>:<minute>'.
lsMedCat() {
	lsUniversal -l --no-group -g --human-readable --time-style="+%b %d %Y %H:%M" "$@"
}

# Calls lsUniversal with: 
#	* use long listing format. 
lsLongCat() {
	lsUniversal -l "$@"
}

# Functions that call aliases above, and pipe output to less.
# They: 
#	* override color option of ls to 'always' and 
#	* pipe output to le with RAW-CONTROL-CHARS option.
# This enables the transfer of colors from ls to less. They also
# start less at end of file.
lsShortLess() { 
	lsShortCat --color=always $* | le --RAW-CONTROL-CHARS +G
}

lsMedLess() { 
	lsMedCat --color=always $* | le --RAW-CONTROL-CHARS +G 
}

lsLongLess() { 
	lsLongCat --color=always $* | le --RAW-CONTROL-CHARS +G 
}

# This functions decide weather they will call cat or less
# version of the lstShort/Med/Long function. It depends on
# whether the output of ls will fit on screen.
lsShort() {
	noOfLines=$(lsShortCat "$@" 2> /dev/null | fold -w"$COLUMNS" |  wc -l)
	if [[ "$LINES" -gt "$noOfLines" ]]; then
		lsShortCat "$@"	
	else
		lsShortLess "$@" 
	fi
}
lsMed() {
	noOfLines=$(lsMedCat "$@" 2> /dev/null | fold -w"$COLUMNS" |  wc -l)
	if [[ "$LINES" -gt "$noOfLines" ]]; then
		lsMedCat "$@"
	else
		lsMedLess "$@"    
	fi
}
lsLong() {
	noOfLines=$(lsLongCat "$@" 2> /dev/null | fold -w"$COLUMNS" |  wc -l)
	if [[ "$LINES" -gt "$noOfLines" ]]; then
		lsLongCat "$@"
	else
		lsLongLess "$@"    
	fi
}

# Calls ls (with a lot of options) that lists only names. Output is sent to pager if necesarry.
alias l='lsShort'
# Calls ls (with a lot of options) that uses shortened long listing format. Output is sent to pager if necesarry.
alias ll='lsMed'
# Calls ls (with a lot of options) that uses long listing format. Output is sent to pager if necesarry.
alias lll='lsLong'

# Calls ls (with a lot of options) that lists only filenames, also showing hidden files. Output is sent to pager if necesarry.
alias la='lsShort --almost-all'
# Calls ls (with a lot of options) that uses shortened long listing format, also showing hidden files. Output is sent to pager if necesarry.
alias lla='lsMed --almost-all'
# Calls ls (with a lot of options) that uses long listing format, also showing hidden files. Output is sent to pager if necesarry.
alias llla='lsLong --almost-all'

# Calls ls (with a lot of options) that lists only names and sorts files by date. Output is sent to pager if necesarry.
alias lt='lsShort -t'
# Calls ls (with a lot of options) that uses shortened long listing format and sorts files by date. Output is sent to pager if necesarry.
alias llt='lsMed -t'
# Calls ls (with a lot of options) that uses long listing format and sorts files by date. Output is sent to pager if necesarry.
alias lllt='lsLong -t'

# Calls ls (with a lot of options) that lists one name per line. Output is sent to pager if necesarry.
alias l1='lsShort -1'
# Calls ls (with a lot of options) that lists one name per line and also shows hidden files. Output is sent to pager if necesarry.
alias la1='la -1'


########
# TREE #
########

# Displays tree structure of current or specified folder.
tree1() {
	tree -C -I .git --dirsfirst "$@" | catOrLess
}
alias t='tree1'


######
# CD #
######

# Aliases that simplify going up in directory hierarchy.
alias cd..='cd ..'
alias ..='cd ..'
alias ,,='cd ..'
alias ...='cd ../..'
alias ,,,='cd ../..'
alias ....='cd ..; cd ..; cd ..;'
alias ,,,,='cd ..; cd ..; cd ..;'
alias .....='cd ..; cd ..; cd ..; cd..'
alias ......='cd ..; cd ..; cd ..; cd..; cd..'
alias .......='cd ..; cd ..; cd ..; cd..; cd..; cd..'

# Combines cd and ls.
cdl() {	
	cd "$@"; l
}


#########
# FILES #
#########

# TODO
# Aliases that make some possibly destructive commands more
# interactive.
alias rmdir='rm -rI'
alias cpdir='cp -arv'
alias rm='rm -i'
alias mv='mv -iv'
alias cp='cp -iv'
alias mvdir='mv'


#######
# PWD #
#######

# Prints PWD.
alias .='echo $PWD'

# If no file specified, prints PWD, else full path of the file.
p() {
	if [ $# -eq 0 ]; then
		echo "$PWD"
	else
		echo `echo "$PWD"`/"$@"
	fi		
}


########
# ECHO #
########

alias e='echo'

# Echo that interpets backslashed characters (\n,...).
alias ee='echo -e'

# Echo withouth new line at the end.
alias en='echo -n'


#####################
# RUN IN BACKGROUND #
#####################

# Runs command in background, it doesn't hang up if the shell
# is closed and it doesn't print output.
runInBackground() {
	nohup "$@" &>/dev/null &
}
alias rb='runInBackground'


##########
# BASICS #
##########

# Runs bash.
alias ba='bash'

# Runs command as sudo.
alias s='sudo'

# Runs cat.
alias c='cat'

# Prints the exit code of the last command.
alias ?='echo $?'

# Clears the screen.
alias cl='clear'

# Resets the screen.
alias re='reset'

# Exits shell.
alias q='exit'

# Runs head.
alias he='head'

# Prints first line.
alias he1='head -n1'

# Runs tail.
alias ta='tail'

# Prints last line of file or piped stream.
alias ta1='tail -n1'

# Counts lines in file or piped stream.
alias wcl='wc -l'

# Counts words in file or piped stream.
alias wcw='wc -w'

# Updates file's timestamp, or creates empty file, if it doesen't exits.
alias to='touch'

# Opens file with default aplication for the file type.
o() {
	rb xdg-open "$@"
}

alias ty='type'

alias da='date'

alias makeToPager='make 2>&1 | le'
alias ma="makeToPager"

# Starts a new terminal.
alias te='gnome-terminal'

# Start a file explorer
alias na='rb nautilus .'

# Makes directory and its subdirectories and descends into.
mkdir1() {
	mkdir -p "$1"
	cd "$1"
}
alias mk='mkdir1'


###########
# HISTORY #
###########

# Greps the history, or just shows it if no argument is passed
grepHistory() {
	if [ "$#" -eq 0 ]; then
		history | catOrLessG
	else
		history | grep "$@" | catOrLessG
	fi
}
alias h='grepHistory'


################
# TEXT EDITORS #
################

# Calls Vim with option that opens one tab per file.
alias v='vim -p'

# Runs Vim in read only mode.
alias vv='view'

# Runs Nano with: 
#	* enable experimental undo (will most probably crash
# if going deeper than first undo level!!!!!!!!!), 
#	* autoindent, 
#	* constantly show the cursor position, 
#	* log search and replace strings,
#	* enable edit of multiple files, 
#	* treat punctuation as part of words, 
#	* smooth scrolling, 
#	* tab size set to 4 spaces.
alias n='nano --undo --autoindent --const --historylog --multibuffer --wordbounds --smooth --tabsize=4'

# Runs Gedit in background.
g() { 
	rb gedit "$@" 
}

# Runs Sublime Text in background.
alias sub='rb sublime_text'


########
# SUDO #
########

# Aliases that run commands, that require sudo, with sudo.
alias fdisk='sudo fdisk'
alias updatedb='sudo updatedb'
alias ifconfig='sudo ifconfig'
alias tcpdump='sudo tcpdump'
alias route='sudo route'
alias pm-hibernate='sudo pm-hibernate'
alias pm-suspend='sudo pm-suspend'
alias shutdown='sudo shutdown'
alias fstrim='sudo fstrim'
alias apt-get='sudo aptget'
alias iw='sudo iw'
alias nmap='sudo nmap'
alias parted='sudo parted'
alias ntfsundelete='sudo ntfsundelete'
alias lshw='sudo lshw'
alias chown='sudo chown'
alias mount='sudo mount'

# Executes last command as sudo.
alias fuck='sudo $(history -p \!\!)'
alias fu='fuck'

# File manipulation 
alias scp='sudo cp -iv'
alias smv='sudo mv -iv'
alias srm='sudo rm -i'

# Dir manipulation 
alias scpdir='sudo cp -arv'
alias smvdir='sudo mv'
alias srmdir='sudo rm -rI'

# Backup file
backup() {
	sudo cp --preserve "$1"{,.bak}
}
alias bk='backup'


sg() { 
	sudo gedit "$*" 
}
sn() {
	sudo nano -icHFwST 4 "$*"
}
sm() {
	sudo le "$*"
}
sv() {
	sudo vim "$*"
}


######
# PS #
######

# Pipe output of ps to catOrLess.
psM() {
	ps "$@" | catOrLess
}
alias ps='psM'

# Print every process on the system.
alias pse='ps -e | catOrLess'
alias psa='ps -e | catOrLess'
alias ps1='ps -e | catOrLess'

# Print matching processes and their pids.
pgrep1() {
	pgrep --list-name "$@" | catOrLess
}


########
# TMUX #
########

# Runs Tmux.
alias tm='tmux'

# Runs Tmux, and attaches to last session.
alias tma='tmux attach'

# Lists all running Tmux sessions.
alias tml='tmux ls'


########
# TEXT #
########

# Removes columns specified by second argument. Specify
# delimiter with first argument.
cut1() {
	cut --delimiter="$1" --fields="$2" 
}

# Sorts lines of file. Specify separator and key. Key is used to
# specify number of field you want lines to be sorted by.
sort1() { 
	sort --field-separator="$1" --key="$2"
}

# Makes table out of input data. You need to specify column
# separator.
alias table='column -t -s'

# Deletes specified characters.
alias trd='tr --delete'

# Changes input strings notation from CamelCase to underscore.
# (all the folowong commands work as pipe filters)
toUnderscore() {
	cat | sed 's/\([A-Z]\)/_\1/g' | tr [a-z] [A-Z]
}

# Changes input strings notation from CamelCase to underscore.
toHypenscore() {
	cat | sed 's/\([A-Z]\)/-\1/g' | tr [A-Z] [a-z] 
}
alias decamelize='toHypenscore'

# Changes input strings notation from CamelCase to underscore.
toCamel() {
	cat | tr [A-Z] [a-z] | sed 's/[_-]\([a-z]\)/\U\1/g'
}


##########
# SYSTEM #
##########

# Shows detailed overview of processes.
alias ht='htop'

# Reports disk space of main partitions in human readable form.
alias df1='df -h | grep "sd\|Size" | cat'

# Resets computer.
alias restart='sudo shutdown -r now'
alias poweroff='sudo shutdown now'

# Hibernates.
alias hib='sudo pm-hibernate'

# Suspends.
alias sus='sudo pm-suspend'

# Traces system calls and signals. Prints strings of maximum
# 2000 chararcters, and also traces child processes.
alias strace1='strace -s 2000 -f'

# Prints all system information.
alias uname1='uname -all'

# Prints verbose information of all PCI devices.
alias lspci1='lspci -v | catOrLess'

# Displays cpu temperature.
alias temp='acpi -t'

# Prints battery status.
alias battery='acpi'
alias batt='acpi'

# Trims SSD disk.
alias trim='sudo fstrim -v /'
alias ssd='trim'

# Changes blue color to blueberry in tty.
alias blue='echo -en "\e]PC7373C9"'

# Sends KILL signal instead of TERM.
alias kill1='kill -9'

# Prints PATH variable, each entry in its own line.
alias path='echo -e ${PATH//:/\\n}'

# Prints all and free memory in megabytes.
fr() {
	echo "all: "$(free -m \
		| grep Mem \
		| sed 's/^Mem: *\([0-9]*\).*/\1/')" MB"
	echo "free: "$(free -m \
		| grep Mem \
	  	| sed 's/^[^ ]*[ ]*[^ ]*[ ]*[^ ]*[ ]*\([^ ]*\)[ ]*[^ ]*[ ]*[^ ]*[ ]*[^ ]*/\1/')" MB"
}

# Displays disk space used by a folder or a file in human
# readable form.
alias du1='du --summarize --human-readable'

# Mounts ISO file and cd-s into it.
mount-iso() {
	sudo mkdir /media/"$1"
	sudo mount -o loop "$1" /media/"$1"
	cd /media/"$1"
}
alias cd-iso='mount-iso'


############
# KEYBOARD #
############

# Sets keyboard layout to us layout.
alias uskeys='setxkbmap -layout us'

# Gets keycode of pressed key.
alias keycode='xev';

# Turns key input repeat off.
alias norepeat='xset -r'

# Turns key input repeat on.
alias repeat='xset r'


##########
# USEFUL #
##########

# Makes grep more user friendly by highlighting matches
# and excludes grepping through .svn and .git folders.
alias grep1='grep --color=auto --exclude-dir=\.svn --exclude-dir=\.git'
gr() {
	grep1 "$@" --ignore-case --perl-regexp --color=always | catOrLess
}
gr1() {
	gr "$@" --ignore-case --perl-regexp --only-matching | catOrLess
}
gr2() {
	egrep "$@" --ignore-case --color=always --exclude-dir=\.svn --exclude-dir=\.git | catOrLess
}

# Creates executable bash script, or just changes modifiers to
# executable, if file already exists.
createExecutable() {
	if [[ ! -f "$1" ]]; then
		echo '#!/bin/bash' >> "$1"
		echo '#' >> "$1"
		echo "# Usage: $1 " >> "$1"
		echo '# ' >> "$1"
		echo >> "$1"
		echo '# Uncomment for Strict mode, more info at:' >> "$1"
		echo '# http://redsymbol.net/articles/unofficial-bash-strict-mode' >> "$1"
		echo '# set -euo pipefail' >> "$1"
		echo "# IFS=$'\n\t'" >> "$1"
		echo >> "$1"
	fi
	chmod u+x "$1"        
}
alias ce=createExecutable
alias me=createExecutable    

# TODO: generig unpackaging command.
# Untars file. (tar xvf)
alias tar1='tar --extract --verbose --file'

# Untars and unzip file. (tar xzvf)
alias tarz='tar --extract --verbose -gunzip --file'
alias untar='tarz'

# Hexadecimal dump.
hd1() {
	hd "$*" | catOrLess
}

locate1() {
	locate "$@" | catOrLess
}

# Recursively searches for files containing pattern in their
# names.  Use filesistem regexes for search (aka *.*), and
# always sureound them with quotation marks.
find1() {
	find . -name "$1" | gr $(echo "$1" | tr -d "\*")
}

# Prints all directories recursively.
alias findd='find . -name .git -prune -o -type d | catOrLess'

# Runs a typing tutor.
alias tt='gtypist'

# Runs console calculator with decimal numbers.
alias bc1='gcalccmd'

# Executes command periodically every 2 seconds. Aliases can be
# also used.
alias watch1='watch bash -i -c'

# Executes command periodically every 10 seconds. Aliases can be
# also used.
alias watch2='watch -n 10 bash -i -c'

# Executes command periodically every 30 seconds. Aliases can be
# also used.
alias watch3='watch -n 30 bash -i -c'

# Sets bash to vi mode.
alias vimode='set -o vi'

# Sets bash to emacs (normal) mode.
alias emacsmode='set -o emacs'

# Gets name of first file in directory.
alias first='ls | head -1'

# Gets name of random file in directory.
# $@ - all arguments get send to ls
randomFile() {
	ls "$@" | sort -R | head -1
}
alias rf='randomFile'

# Runs profile script.
alias profile='source /etc/profile'

# Switches the files. Usage: switch [FILE1] [FILE2]
switch() {
	TMP_NAME="f8ewn3j9"
	cp "$1" "$TMP_NAME"
	mv -f "$2" "$1"
	mv "$TMP_NAME" "$2"
}

diff1() {
	colordiff "$@" | catOrLess
}

# TODO: to here

############
# PACKAGES #
############

# Apt-get.
alias canhaz='sudo apt-get install'
alias ch='canhaz'
alias update='sudo apt-get update'
alias upgrade='sudo apt-get upgrade'
alias dist-upgrade='sudo apt-get dist-upgrade'
alias remove='sudo apt-get remove && autoremove'
alias purge='sudo apt-get purge && autoremove'
alias autoremove='sudo apt-get autoremove'

# Show installed and remote version.
alias version='apt-cache policy'
alias ve='apt-cache policy'

# Show packages' dependencies.
depends() {
	apt-cache show "$@" | grep Depends | sed 's/Depends:/ /' | sed 's/,/\n /g'
}

# Print installed packages
alias packages1='dpkg --get-selections | grep -v deinstall | catOrLess'

# Print packages that were installed by the user, in order of
# installation
alias packages='cat /var/log/apt/history.log | grep "apt-get install" | sed "s/.* //" | catOrLessG'
alias installed='packages'

# Apropos.
aproposM() {
	apropos "$*" | catOrLess
}
alias apropos='aproposM'
alias ap='apropos'

# Run apropos with passed string, then grep output with same
# string.
aproposMG() {
	apropos "$*" | gr "$*" 
}
alias apg='aproposMG'

# Search packages, that can be installed with apt-get.
apropos1() {
	apt-cache search "$*" | catOrLess
}
alias ap1='apropos1'

# Same, but grep output with same string.
apropos1G() {
	apt-cache search "$*" | gr "$*"
}
alias ap1g='apropos1G'
alias search='apropos1G'

# Same, but only search for packages containing string in their
# name
apropos2G() {
	apt-cache search "$@" | gr "^[^ ]*$@[^ ]*" 
}
alias ap2g='apropos2G'

# Searches packages based on their name and also by their
# executables
y() {
	(echo   "PACKAGES CONTAINING EXECUTABLES NAMED \"$1\""
	echo -n "========================================"
	echo "$1" | sed 's/./=/g'
	apt-file1 "$@" | gr "^.*:"
	echo -e "\nPACKAGES CONTAINING \"$@\" IN THEIR NAMES"	
	echo -n   "====================================="
	echo "$1" | sed 's/./=/g'
	apropos2G "$@") | le 
}

# Find to which of the installed packages passed command belongs
# to
package() {
	file=$(sudo which "$1")
	if [ "$file" == "" ]; then 
		return
	fi	
	resolved=$(readlink -f "$file")
	dpkg -S "$resolved" 
}

# Find to which of all the packages the command belongs to
apt-file1() {
	apt-file search "$1" | grep \/"$1"$ | catOrLess 
}


alias wi1='whatis'
# Prints package description. (Few lines)
whatis2() {
	apt-cache show "$*" | grep "^ " | catOrLess
}
alias wi2='whatis2'

# Searches aliases for name
whatis3() {
	type "$*" | catOrLess
}
alias wi3='whatis3'

# Searches all packages for file
whatis4() {
	package "$@"
}
alias wi4='whatis4'

# Searches all packages for file
whatis5() {
	apt-file1 "$@"
}
alias wi5='whatis5'

# Searches all packages for keyword 
whatis6() {
	search "$@"
}
alias wi6='whatis6'

# Converts man section number to a description
manSection() {
	case "$1" in
		1)
			echo "user command"
			;;
		2)
			echo "system call"
			;;
		3)
			echo "c function"
			;;
		4)
			echo "device file"
			;;
		5)
			echo "file format or convention"
			;;
		6)
			echo "game"
			;; 
		7)
			echo "miscallaneous"
			;;
		8)
			echo "su command"
			;;
		9)
			echo "kernel routine"
			;;
	esac
}

# Universal command description search function. First tries
# whatis, then apt-cache show, then type and finally apt-file.
# When one of them succeeds in finding the description the
# function returns.
whatIs() {
	call1=`whatis "$@" 2> /dev/null`
	if [ "$?" == "0" ]; then
		while IFS= read -r line; do
			commandType=$(manSection $(echo "$line" | sed 's/.*(\([1-9]\)).*/\1/'))
			echo "$line" "($commandType)"
		done <<< "$call1"
		echo -n "package: "
		package "$@" | sed 's/:/\nlocation:/'
		return
	fi

	call2=`apt-cache show "$*" 2> /dev/null | grep "^ "`
	if [ "$?" == "0" ]; then
		echo "$call2" | catOrLess
		return
	fi

	call3=`type "$*" 2> /dev/null`
	if [ "$?" == "0" ]; then
		echo "$call3"
		return
	fi

	call4=`package "$@"`
	if [ "$call4" != "" ]; then
		echo "$call4"
		return
	fi

	call5=`apt-file1 "$@" | gr "^.*:"`
	if [ "$call5" != "" ]; then
		echo -e "You need to install one of the following packages to get the command:\n$call5" | catOrLess
	fi

	call6=`search "$@"`
	if [ "$call6" != "" ]; then
		echo  "$call6" | catOrLess
	fi
}
alias wi='whatIs'


#######
# GIT #
#######

alias commit='git commit -am'
alias commitm='git commit -a'
alias init='git init'
alias push='git push'
alias pull='git pull'
alias checkout='git checkout'
alias merge='git merge'
alias branch='git branch'

clone() {
	git clone git@github.com:/"$1".git
}

alias gs='git -c color.status=always status -sb | catOrLess'
# Nicely decorated graph of commits
alias gl='git log --decorate --graph --all'
alias gl1="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"
alias gl2="git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n''          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all"
# Update information about state of the origin and print status
alias gu='git remote update; git status -sb'
alias gd='git diff'
alias ga='git add'
alias gm='git mv'
alias gll='git ls-files'
alias gb='git branch'
alias gc='git checkout'

# Add to github (first create remote repository on website,
# init local repo and add files to it):
# Parameter: <USERNAME>/<PROJECT>
origin() {
	git remote add origin git@github.com:/"$1".git
	git pull origin master
	git push origin master
}

# GIT MISC:

# Usage: cloneAll <github-username>
# Clones all users github repos in pwd.
cloneAll() {
	if [[ -z "$1" ]]; then
		exit
	fi

	tempFile=`mktemp`
	wget 'https://github.com/gto76?tab=repositories' -O "$tempFile"
	repos=`grep "$1"/[^//\"]* -o "$tempFile" | sort -u | grep -v follow`

	while read -r line; do
		git clone git@github.com:"$line"
	done <<< "$repos"
}


#################
# LINE COUNTING #
#################

# Counts number of lines in files with extension $1 
# in current and sub directories.
noOfLines() {
	rootDir="$PWD"
	no=0
	for file in *; do
		if [ -d "$file" ]; then
			#echo "entering $file" >&2
			cd "$file"
			recRes=`noOfLines "$1"`
			#echo "recRes is $recRes" >&2
			let no=$no+"$recRes"
			cd "$rootDir"
		fi
		if [[ "$file" == *."$1" ]]; then
			let no=$no+`cat "$file" | wc -l`	
		fi
	done
	echo $no
}
alias loc='noOfLines'

# TODO from here up
# Same as noOfLines, but prints results per top directory.
locall() {
	table=$(for project in *; do 
		cd "$project"
		echo -n "$project;" 
		lines=`loc "$1"`
		echo "$lines" 
		cd..
	done)
	sum=`echo "$table" | grep -o [0-9]*$ | sumall` 
	folder=`echo $PWD | grep -o "[^/]*$" | tr [a-z] [A-Z]`
	echo "$folder;$sum"
	echo "$table"
}

# Sums all the numbers.
sumall() {
	in=`cat`
	sum=0
	for line in `echo "$in"`; do 
		let sum=sum+"$line"
	done
	echo "$sum"
}


###########
# NETWORK #
###########

# Prints internal ip.
ip1() {
	/sbin/ifconfig \
		| grep "inet addr:192.168" \
		| grep -o addr:[0-9.]* \
		| grep -o [0-9.]\* \
		| cat 
}

# Prints external ip. 
alias ip2='echo `lynx --dump http://ipecho.net/plain | grep -o [0-9.]\*`'

# Prints gateways ip.
alias gateway='route -n | grep "192.168." | head -n1 | grep -o "192.168.[0-9.]*"'

# Prints mac addresses of local devices.
alias mac='ifconfig | grep HWaddr | cat'

# Pings gateway, ip address of noip.com and www.google.com.
pingAll() {
	ping -c 1 -q `gateway` | grep --color=never -A 1 statistics
	ping -c 1 -q 8.23.224.107 | grep --color=never -A 1 statistics
	ping -c 1 -q www.google.com | grep --color=never -A 1 statistics
}
alias pa=pingAll

# Scans first $1 addreses of local network.
nmap2() {
  if [ $# -eq 0 ]
  then
    third=`ip1 | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta'`
    forth="254"
  fi
  if [ $# -eq 1 ]
  then
    third=`ip1 | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta'`
    forth="$1"
  fi
  if [ $# -gt 1 ]
  then
    third="$1"
    forth="$2"
  fi
  nmap -sP 192.168.$third.0-$forth
}

# Scans first 20 addreses of local network.
alias nmap1='nmap2 20'

# Retrurns OK if pingable of Fail if not. Parameter is an ip or
# domain.
pingable() {
	pingResult=$(ping -c 1 -q "$1" | grep --color=never -A 1 statistics | grep "1 received")
	if [ "$pingResult" != "" ]; then
		echo -n "OK"
	else
		echo -n "Fail"
	fi
}

# Prints status of the ssh port of the passed client.
port22status() {
	nmap $(echo "$1" | tr -d ' ') -p22 | grep '22/tcp' | sed 's/^[^ ]* \([^ ]*\) .*$/\1/'
}

# Scans the network and prints the ip-s of the conncted devices,
# and checks if connection to the internet is avalable.
network() {
	localIp=$(ip1)
	gateway=$(gateway)
	echo "You:      $localIp   ssh: $(port22status $(ip2))"
	echo "Gateway:  $gateway    ssh: $(port22status "$gateway")"
	all=$(nmap1)
	allFiltered=$(
		echo "$all" | 
		grep -v "$localIp" |
		grep -v "$gateway" |
		grep -o "[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*" |
		sed 's/^/          /g' ) 
	len=${#allFiltered} 
	allFiltered=${allFiltered:6:len-6} 
	echo -n "Other:"

	while IFS= read -r line; do	
		echo -n "$line    ssh: "
		port22status "$line"	
	done <<< "$allFiltered"

	testIp="8.23.224.107"
	echo "Internet: $testIp   Ping: $(pingable "$testIp")"
	testDomain="www.google.com"
	echo "          $testDomain Ping: $(pingable "$testDomain")"
}
alias ne='network'


############
# WIRELESS #
############

# Blocks wireless device.
alias woff='sudo rfkill block $(sudo rfkill list | grep Wireless | grep ^[0-9] -o)'

# Unblocks wireless device.
alias won='sudo rfkill unblock $(sudo rfkill list | grep Wireless | grep ^[0-9] -o)'

# Resets wireless device.
alias wr='woff; won'

# Sets wlan up.
alias up='sudo ifconfig wlan0 up'

# Sets wlan down.
alias down='sudo ifconfig wlan0 down'

# Displays wireless networks in range.
wlan() {
	sudo iwlist wlan0 scan \
		| grep Quality -A2 \
		| tr -d "\n" \
		| sed 's/--/\n/g' \
		| sed -e 's/ \+/ /g' \
		| sort -r \
		| sed 's/ Quality=//g' \
		| sed 's/\/70 Signal level=-[0-9]* dBm Encryption key:/ /g' \
		| sed 's/ ESSID:/ /g'
}


############
# INTERNET #
############

# Runs default browser in background.
i() {
	rb sensible-browser "$@"
}

# Runs Firefox in background.
fire() {
	rb firefox "$@"
}

# Runs Chrome in background with setting that resolves some bug
# in some cases (it is probably already fixed).
chrome() { 
	rb google-chrome --touch-devices=123 "$@" 
}

# Runs Lynx with:
#	* accepting cookies, 
#	* starting in Google and
#	* using vim mode for navigation.
alias lynx1='lynx -accept_all_cookies -vikeys www.google.com'


#########
# AUDIO #
#########

# Set volume in console for all audio channels.
alias mixer='alsamixer'

# Set master volume in rage of 0 to 100.
setVolume() {
	amixer set Master playback "$1"
}
# Volume up 6dB.
a() {
	setVolume "6%+" | tail -n 1
}
# Volume down 6dB.
z() {
	setVolume "6%-" | tail -n 1
}
# Volume up 2 dB.
aa() {
	setVolume "2%+" | tail -n 1
}
# Volume down 2 dB.
zz() {
	setVolume "2%-" | tail -n 1
}

