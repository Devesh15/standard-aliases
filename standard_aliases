#!/bin/bash

#    _               _              _ _                     
#   | |__   __ _ ___| |__      __ _| (_) __ _ ___  ___  ___ 
#   | '_ \ / _` / __| '_ \    / _` | | |/ _` / __|/ _ \/ __|
#  _| |_) | (_| \__ \ | | |  | (_| | | | (_| \__ \  __/\__ \
# (_)_.__/ \__,_|___/_| |_|   \__,_|_|_|\__,_|___/\___||___/
#


########
# LESS #
########

# Runs less with a few sensible options.
#   * ignore case when searching, 
#   * do not ring a bell,
#   * do not mark empty lines with ~, 
#   * format prompt as "<page-number>/<all-pages> <filename>",
#   * set tabs to 4 spaces.
__displayTextInPager() {
    less --ignore-case --QUIET --tilde -P"%db/%D %f" --tabs=4 "$@"
}
alias less1='__displayTextInPager'
alias le='__displayTextInPager'

# Runs cat or less, depending on number of lines in file or
# input. First argument must be either 'true' or some other
# value, true meaning that lessgets run with G option. G option
# starts less at the end of the input (scrolled to the bottom).
__printOrDisplayTextInPagerWithOrWithoutStartingAtEnd() {
    if [[ "$#" -gt 1 ]]; then
        noOfLines=$(cat "$2" 2>/dev/null \
            | fold -w"$COLUMNS" \
            | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            cat "$2"
        else
            if [[ "$1" == 'true' ]]; then
                __displayTextInPager +G "$2" 2>/dev/null
            else
                __displayTextInPager "$2" 2>/dev/null
            fi
        fi
    else
        input=$(cat)
        noOfLines=$(echo "$input" | fold -w"$COLUMNS" | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            echo "$input" | cat 
        else
            if [[ "$1" == 'true' ]]; then
                echo "$input" | __displayTextInPager +G 2>/dev/null
            else
                echo "$input" | __displayTextInPager 2>/dev/null
            fi
        fi
    fi
}

# Runs cat or less, depending on number of lines in file or
# input.
__printOrDisplayTextInPager() {
    __printOrDisplayTextInPagerWithOrWithoutStartingAtEnd 'false' "$@"
}
alias m='__printOrDisplayTextInPager'

# Open cat or less +G (starts at the end of file), depending on
# no of lines of file or input.
__printOrDisplayTextInPagerStartingAtEnd() {
    __printOrDisplayTextInPagerWithOrWithoutStartingAtEnd 'true' "$@"
}

# If file specified then runs cat or less, depending on no of
# lines of file. If input is piped, then it prints line by
# line. If all screen is filled, then it runs less.
__printAndDisplayTextInPagerIfNecessary() {
    if [[ "$#" -gt 0 ]]; then
        noOfLines=$(cat "$1" 2>/dev/null \
            | fold -w"$COLUMNS" \
            | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            cat "$1"
        else
            __displayTextInPager "$1" 2>/dev/null 
        fi
    else
        noOfLines=0
        input=""
        while read -r line; do 
            input+=("$line")
            realLines=$(echo "$line" | fold -w"$COLUMNS" | wc -l)
            let noOfLines="$noOfLines"+"$realLines"
            if [ $noOfLines -gt $LINES ]; then 
                (for inputLine in "${input[@]}"; do
                    echo "$inputLine" 
                done
                while read -r line; do 
                    echo "$line"
                done) | less 2>/dev/null
                exit 
            fi   
            echo "$line"
        done 
    fi   
}
alias mm='__printAndDisplayTextInPagerIfNecessary'


######
# LS #
######

# All other ls aliases end up calling this one. It runs ls with:
#   * append indicator, 
#   * sort alphabetically by extension, 
#   * list by columns, 
#   * use color when stdout is connected to terminal, 
#   * group directories before files.
#__listDirectoryContents
lsWithSensibleOptions() {
    ls --classify -X -C --color=auto --group-directories-first "$@"
}

# Calls lsWithSensibleOptions with: 
#   * set width to screen width or 69, whichever is smaller.
#__listDirectoryContentsUsingShortListingFormat
lsShortCat() {
    width=$(
        widthLimit=69
        if [[ "$COLUMNS" -lt "$widthLimit" ]]; then 
            echo "$COLUMNS"
        else 
            echo "$widthLimit"
        fi)
    lsWithSensibleOptions --width="$width" "$@"
}

# Calls lsWithSensibleOptions with: 
#   * use long listing format, 
#   * do not print groups,
#   * do not list owner, 
#   * print sizes in human readable format, 
#   * print date as: '<month-by-word>, <day-of-month>, <year>,
#   <hour>:<minute>'.
#__listDirectoryContentsUsingMediumListingFormat
lsMedCat() {
   lsWithSensibleOptions -l --no-group -g --human-readable \
        --time-style="+%b %d %Y %H:%M" "$@"
}

# Calls lsWithSensibleOptions with: 
#   * use long listing format.
#__listDirectoryContentsUsingLongListingFormat
lsLongCat() {
   lsWithSensibleOptions -l "$@"
}

# $1 - function that lists dir contents
# ... - rest of parameters
__displayDirectoryContentsInPagerUsingProvidedFunction() {
    listDirContents="$1"
    shift
    "$listDirContents" --color=always "$@" \
        | __displayTextInPager --RAW-CONTROL-CHARS +G 
}

# Calls lsShortCat and sends output to pager.
#__displayDirectoryContentsInPagerUsingShortListingFormat
lsShortLess() { 
    #__displayDirectoryContentsInPagerUsingProvidedFunction lsShortCat "$@"
    lsShortCat --color=always "$@" \
        | __displayTextInPager --RAW-CONTROL-CHARS +G
}

# Calls lsMedCat and sends output to pager.
#__displayDirectoryContentsInPagerUsingMediumListingFormat
lsMedLess() {
    #__displayDirectoryContentsInPagerUsingProvidedFunction lsMedCat "$@"
    lsMedCat --color=always "$@" \
        | __displayTextInPager --RAW-CONTROL-CHARS +G 
}

# Calls lsLongCat and sends output to pager.
#__displayDirectoryContentsInPagerUsingLongListingFormat
lsLongLess() { 
    #__displayDirectoryContentsInPagerUsingProvidedFunction lsLongCat "$@"
    lsLongCat --color=always "$@" \
        | __displayTextInPager --RAW-CONTROL-CHARS +G 
}

# $1 - function that lists dir contents
# $2 - function that displays dir contents in pager
# ... - rest of parameters
__listOrDisplayDirectoryContentsInPagerUsingProvidedFunctions() {
    listDirContents="$1"
    shift
    displayDirContentsInPager="$1"
    shift
    noOfLines=$(
        "$listDirContents" "$@" 2> /dev/null \
            | fold -w"$COLUMNS" \
            |  wc -l)
    if [[ "$LINES" -gt "$noOfLines" ]]; then
        "$listDirContents" "$@" 
    else
        "$displayDirContentsInPager" "$@" 
    fi
}

# TODO combine
# Calls lsShortCat if it's output fits on screen, otherwise
# calls lsShortLess.
#__listOrDisplayDirectoryContentsInPagerUsingShortListingFormat
lsShort() {
    __listOrDisplayDirectoryContentsInPagerUsingProvidedFunctions \
        lsShortCat lsShortLess "$@"
}
alias l='lsShort'

# Calls lsMedCat if it's output fits on screen, otherwise calls
# lsMedLess.
#__listOrDisplayDirectoryContentsInPagerUsingMediumListingFormat
lsMed() {
    __listOrDisplayDirectoryContentsInPagerUsingProvidedFunctions \
        lsMedCat lsMedLess "$@"
}
alias ll='lsMed'

# Calls lsLongCat if it's output fits on screen, otherwise calls
# lsLongLess.
#__listOrDisplayDirectoryContentsInPagerUsingLongListingFormat
lsLong() {
    __listOrDisplayDirectoryContentsInPagerUsingProvidedFunctions \
        lsLongCat lsLongLess "$@"
}
alias lll='lsLong'


# Calls ls (with a lot of options) that shows hidden files.
#__listOrDisplayAllDirectoryContentsInPagerUsingShortListingFormat
lsShortShowHiddenFiles() {
    lsShort --almost-all "$@"
}
alias la='lsShortShowHiddenFiles'

# Calls ls (with a lot of options) that shows hidden files,
# using shortened long listing format.
#__listOrDisplayAllDirectoryContentsInPagerUsingMediumListingFormat
lsMedShowHiddenFiles() {
    lsMed --almost-all "$@"
}
alias lla='lsMed --almost-all'

# Calls ls (with a lot of options) that shows hidden files,
# using  long listing format.
#__listOrDisplayAllDirectoryContentsInPagerUsingLongListingFormat
lsLongShowHiddenFiles() {
    lsLong --almost-all "$@"
}
alias llla='lsLongShowHiddenFiles'

# Calls ls (with a lot of options) that sorts files by date.
#__listOrDisplayDirectoryContentsInPagerOrderedByDateUsingShortListingFormat
lsShortOrderByDate() {
    lsShort -t "$@"
}
alias lt='lsShortOrderByDate'

# Calls ls (with a lot of options) that sorts files by date,
# using shortened long listing format.
#__listOrDisplayDirectoryContentsInPagerOrderedByDateUsingMediumListingFormat
lsMedOrderByDate() {
    lsMed -t "$@"
}
alias llt='lsMedOrderByDate'

# Calls ls (with a lot of options) that sorts files by date,
# using long listing format.
#__listOrDisplayDirectoryContentsInPagerOrderedByDateUsingLongListingFormat
lsLongOrderByDate() {
    lsLong -t "$@"
}
alias lllt='lsLongOrderByDate'

# Calls ls (with a lot of options) that lists directories
# matching pattern.
#__listOrDisplayMatchingDirectoriesInPagerUsingShortListingFormat
lsShortListMatchingDirectories() {
    lsShort --directory "$@"
}
complete -F _filedir lsShortListMatchingDirectories 
alias dl='lsShortListMatchingDirectories'

# Calls ls (with a lot of options) that lists directories
# matching pattern, using shortened long format.
#__listOrDisplayMatchingDirectoriesInPagerUsingMediumListingFormat
lsMedListMatchingDirectories() {
    lsMed --directory "$@"
}
complete -F _filedir lsMedListMatchingDirectories 
alias dll='lsMedListMatchingDirectories'

# Calls ls (with a lot of options) that lists directories
# matching pattern, using long format.
#__listOrDisplayMatchingDirectoriesInPagerUsingLongListingFormat
lsLongListMatchingDirectories() {
    lsLong --directory
}
complete -F _filedir_xspec lsLongListMatchingDirectories 
alias dlll='lsLongListMatchingDirectories'

# Calls ls (with a lot of options) that lists one name per line.
#__listOrDisplayInPagerOneDirectoryItemPerLineUsingShortListingFormat
lsShortOnePerLine() {
    lsShort -1 "$@"
}
alias l1='lsShortOnePerLine'

# Calls ls (with a lot of options) that lists one name per line
# and also shows hidden files.
#__listOrDisplayInPagerOneDirectoryItemPerLineIncludingHiddenFilesUsingShortListingFormat
lsShortShowHiddenFilesOnePerLine() {
    la -1 "$@"
}
alias la1='lsShortShowHiddenFilesOnePerLine'

# Gets name of first file in the directory.
#__getFirstFileInDirectory
__getFirstFileInDir() {
    ls | head -1
}
alias first='__getFirstFileInDir'

# Gets name of a random file in the directory.
#__getRandomFileInDirectory
__getRandomFileFromDir() {
    ls "$@" | sort -R | head -1
}
alias randomFile='__getRandomFileFromDir'
alias rf='__getRandomFileFromDir'


########
# TREE #
########

# Displays tree structure of current or specified folder.
__printDirectoryStructure() {
    tree -C -I .git --dirsfirst "$@" | __printOrDisplayTextInPager
}
alias tree1='__printDirectoryStructure'
alias t='__printDirectoryStructure'


######
# CD #
######

# Goes up in the directory hierarchy the specified number of
# levels.
__goUpNumberOfDirectories() {
    if [[ "$#" -lt 1 ]]; then
        # Needs parameter.
        return 1
    fi
    re='^[1-9]$'
    if ! [[ "$1" =~ $re ]] ; then
        # Parameter is not a number or it's not the right size.
        return 2
    fi
    i=1
    while [[ "$i" -le "$1" ]]; do
        cd ..
        i=$(($i + 1))
    done
}

alias cd..='__goUpNumberOfDirectories 1'
alias ..='__goUpNumberOfDirectories 1'
alias ,,='__goUpNumberOfDirectories 1'
alias ...='__goUpNumberOfDirectories 2'
alias ,,,='__goUpNumberOfDirectories 2'
alias ....='__goUpNumberOfDirectories 3'
alias ,,,,='__goUpNumberOfDirectories 3'
alias .....='__goUpNumberOfDirectories 4'
alias ......='__goUpNumberOfDirectories 5'
alias .......='__goUpNumberOfDirectories 6'

# Mounts ISO file and cd-s into it.
__mountIsoAndCdInto() {
    sudo mkdir /media/"$1"
    sudo mount -o loop "$1" /media/"$1"
    cd /media/"$1"
}
alias cdiso='__mountIsoAndCdInto'


#########
# FILES #
#########

# Runs cp in interactive mode (asks before it overwrites
# anything).
__copyFilesSafely() {
    cp --interactive --verbose "$@"
}
alias cp='__copyFilesSafely'

# Runs mv in interactive mode (asks before it overwrites
# anything).
__moveFilesSafely() {
    mv --interactive --verbose  "$@"
}
alias mv='__moveFilesSafely'

# Runs rm in interactive mode (asks you for every file, if you
# really want to delete it). Run with -f option to override
# interactive mode.
__deleteFilesSafely() {
    rm --interactive "$@"
}
alias rm='__deleteFilesSafely'

# Copies whole directory in interactive mode (asks before it
# overwrites anything).
__copyDirectoriesSafely() {
    cp --interactive --verbose --archive --recursive "$@"
}
complete -F _filedir_xspec __copyDirectoriesSafely 
alias cpdir='__copyDirectoriesSafely'

# Moves whole directory in interactive mode (asks before it
# overwrites anything).
__moveDirectoriesSafely() {
    mv --interactive --verbose "$@"
}
complete -F _filedir_xspec __moveDirectoriesSafely 
alias mvdir='__moveDirectoriesSafely'

# Removes whole directory in interactive mode (checks for every
# file if you really want to delete it). Run with -f option to
# override interactive mode.
__removeDirectoriesSafely() {
    rm --interactive --recursive "$@"
}
#TODO find correct complete
complete -F _filedir_xspec __removeDirectoriesSafely 
alias rmdir='__removeDirectoriesSafely'

# Makes directory (and its parent directories if necessary) and
# descends into.
__createDirectoryAndDescendInto() {
    mkdir --parents "$1"
    cd "$1"
}
alias mkdir1='__createDirectoryAndDescendInto'
alias mk='__createDirectoryAndDescendInto'

# Backups file, by making a copy with '.bak' extension. All
# file's attributes are preserved.
__backupFile() {
    sudo cp --preserve "$1"{,.bak}
}
alias backup='__backupFile'
alias bk='__backupFile'

# Switches the contents of two specified files.
__switchContentsOfFiles() {
    tempFile=$(mktemp)
    sudo cp "$1" "$tempFile"
    sudo cp -f --no-preserve=mode,ownership "$2" "$1"
    sudo cp -f --no-preserve=mode,ownership "$tempFile" "$2"
}
alias switch='__switchContentsOfFiles'


#######
# PWD #
#######

# If no file specified, prints working directory, else full path
# of the file.
__printWorkingDirectoryOrPathToFile() {
    if [[ $# -eq 0 ]]; then
        echo "$PWD"
    else
        echo "$PWD"/"$@"
    fi      
}
alias p='__printWorkingDirectoryOrPathToFile'


########
# ECHO #
########

# Runs echo.
__printText() {
    echo "$@"
}
alias e='__printText'

# Runs echo that interprets backslashed characters (\n,...).
__printTextInterpretingBackslashedCharacters() {
    echo -e "$@"
}
alias ee='__printTextInterpretingBackslashedCharacters'

# Runs echo that doesn't print new line at the end.
__printTextWithoutTrailingNewline() {
    echo -n "$@"
}
alias en='__printTextWithoutTrailingNewline'


#####################
# RUN IN BACKGROUND #
#####################

# Runs command in background. It doesn't hang up if shell
# is closed and it doesn't print output.
__runCommandInBackground() {
    nohup "$@" &>/dev/null &
}
complete -F _command __runCommandInBackground
alias runInBackground='__runCommandInBackground'
alias rb='__runCommandInBackground'


##########
# BASICS #
##########

# Opens this file in Vim.
__editStandardAliases() {
    vim ~/.standard_aliases
}
alias aliases='__editStandardAliases'
alias al='__editStandardAliases'

# Runs bash. Run this command for changes to this file to take
# effect!
__startNewBashShell() {
    bash "$@"
}
alias ba='__startNewBashShell'

# Prints location of specified command, or it's definition, if
# it is an alias. Run this command if you are not sure what an
# alias does!
__printLocationOfCommandOrAliasDefinition() {
    type "$@" | __printOrDisplayTextInPager
}
complete -F _command __printLocationOfCommandOrAliasDefinition
alias type1='__printLocationOfCommandOrAliasDefinition'
alias ty='__printLocationOfCommandOrAliasDefinition'

# Runs cat.
__printContentsOfFile() {
    cat "$@"
}
alias c='__printContentsOfFile'

# Prints the exit code of the last command.
__printExitCodeOfLastCommand() {
    echo $?
}
alias exitCode='__printExitCodeOfLastCommand'
alias ?='__printExitCodeOfLastCommand'

# Clears the screen.
__clearTheScreen() {
    clear
}
alias cl='__clearTheScreen'

# Resets the screen.
__resetTheScreen() {
    reset "$@"
}
alias re='__resetTheScreen'

# Exits shell.
__exitBashShell() {
    exit
}
alias q='__exitBashShell'

# Opens file with default application for it's file type, and
# runs in background.
__openFileWithDefaultApp() {
    __runCommandInBackground xdg-open "$@"
}
alias openFile='__openFileWithDefaultApp'
alias o='__openFileWithDefaultApp'

# Starts a new terminal, with same working directory. 
__openNewTerminalWithSameWorkingDirectory() {
    gnome-terminal "$@"
}
alias terminal='__openNewTerminalWithSameWorkingDirectory'
alias te='__openNewTerminalWithSameWorkingDirectory'

# Runs head (prints first 10 lines of file or piped stream).
__printFirst10Lines() {
    head "$@"
}
alias he='__printFirst10Lines'

# Prints first line of file or piped stream.
__printFirstLine() {
    head -n1 "$@"
}
alias firstLine='__printFirstLine'
alias he1='__printFirstLine'

# Runs tail (prints last 10 lines of file or piped stream).
__printLast10Lines() {
    tail "$@"
}
alias ta='__printLast10Lines'

# Prints last line of file or piped stream.
__printLastLine() {
    tail -n1 "$@"
}
alias lastLine='__printLastLine'
alias ta1='__printLastLine'

# Counts lines in file or piped stream.
__countLines() {
    wc -l "$@"
}
alias countLines='__countLines'
alias wcl='__countLines'

# Counts words in file or piped stream.
__countWords() {
    wc -w "$@"
}
alias countWords='__countWords'
alias wcw='__countWords'

# Updates file's timestamp, or creates empty file, if it doesn't
# exits.
__updateFilesTimestampOrCreateNewOne() {
    touch "$@"
}
alias to='__updateFilesTimestampOrCreateNewOne'

# Prints current date and time.
__printDateAndTime() {
    date "$@"
}
alias da='__printDateAndTime'

# Runs make and sends both 'out' and 'error' streams to pager if
# necessary.
__runMakeWithPager() {
    make 2>&1 | __displayTextInPager
}
#TODO check if exists
. /usr/share/bash-completion/completions/make
complete -F _make  __runMakeWithPager
alias make1='__runMakeWithPager'
alias ma='__runMakeWithPager'

# Start Nautilus file explorer in background.
__startFileExplorerInBackgroundInWorkingDir() {
    __runCommandInBackground nautilus .
}
alias explorer='__startFileExplorerInBackgroundInWorkingDir'
alias na='__startFileExplorerInBackgroundInWorkingDir'

# Runs diff with colors and sends output to pager if necessary.
__compareFilesLineByLineInColors() {
    colordiff "$@" | __printOrDisplayTextInPager
}
alias diff1='__compareFilesLineByLineInColors'

# Creates executable bash script, or just changes modifiers to
# executable, if file already exists.
__makeFileExecutableOrCreateNewBashScript() {
    if [[ ! -f "$1" ]]; then
        echo '#!/bin/bash' >> "$1"
        echo '#' >> "$1"
        echo "# Usage: $1 " >> "$1"
        echo '# ' >> "$1"
        echo >> "$1"
        echo '# Uncomment for Strict mode, more info at:' >> "$1"
        echo -n '# http://redsymbol.net/articles/' >> "$1"
        echo 'unofficial-bash-strict-mode' >> "$1"
        echo '# set -euo pipefail' >> "$1"
        echo "# IFS=$'\n\t'" >> "$1"
        echo >> "$1"
    fi
    chmod u+x "$1"        
}
alias makeExecutable='__makeFileExecutableOrCreateNewBashScript'
alias me='__makeFileExecutableOrCreateNewBashScript'  


###########
# HISTORY #
###########

# Searches command history for pattern, or if none is specified,
# prints it whole.
__searchCommandHistoryForPattern() {
    if [ "$#" -eq 0 ]; then
        history | __printOrDisplayTextInPagerStartingAtEnd
    else
        history | grep "$@" | __printOrDisplayTextInPagerStartingAtEnd
    fi
}
alias history1='__searchCommandHistoryForPattern'
alias h='__searchCommandHistoryForPattern'


################
# TEXT EDITORS #
################

# Calls Vim with option that opens one tab per file.
__editFileWithVim() {
    vim -p "$@"
}
alias vim1='__editFileWithVim'
alias v='__editFileWithVim'

# Runs Vim in read only mode, and with option that opens one tab
# per file.
__viewFileInVim() {
    view -p "$@"
}
alias vv='__viewFileInVim'

# Runs Nano with a few sensible options.
#   * enable experimental undo (will most probably crash
# if going deeper than first undo level!!!!!!!!!), 
#   * autoindent, 
#   * constantly show the cursor position, 
#   * log search and replace strings,
#   * enable edit of multiple files, 
#   * treat punctuation as part of words, 
#   * smooth scrolling, 
#   * tab size set to 4 spaces.
__editFileWithNano() {
    nano --undo --autoindent --const --historylog \
        --multibuffer --wordbounds --smooth --tabsize=4 "$@"
}
alias nano1='__editFileWithNano'
alias n='__editFileWithNano'

# Runs Gedit in background.
__editFileWithGedit() {
    __runCommandInBackground gedit "$@"
}
alias g='__editFileWithGedit'

# Runs Sublime Text in background.
__editFileWithSublimeText() {
    __runCommandInBackground sublime_text "$@"
}
alias sub='__editFileWithSublimeText'


########
# SUDO #
########

# Alias that puts 'sudo' in front of a command that needs super
# user privileges to run.
# As long as this line of text stays here and is not modified,
# that long all the aliases and functions until next comment
# will not get documented in README.md.
# TODO check completions
alias fdisk='sudo fdisk'
alias updatedb='sudo updatedb'
alias ifconfig='sudo ifconfig'
alias tcpdump='sudo tcpdump'
alias route='sudo route'
alias pm-hibernate='sudo pm-hibernate'
alias pm-suspend='sudo pm-suspend'
alias shutdown='sudo shutdown'
alias fstrim='sudo fstrim'
alias apt-get='sudo aptget'
alias iw='sudo iw'
alias nmap='sudo nmap'
alias parted='sudo parted'
alias ntfsundelete='sudo ntfsundelete'
alias lshw='sudo lshw'
alias chown='sudo chown'
alias mount='sudo mount'

# Runs command as sudo.
__runCommandAsSuperUser() {
    sudo "$@"
}
complete -F _command __runCommandAsSuperUser
alias s='__runCommandAsSuperUser'

# Executes last command as sudo.
__executeLastCommandAsSuperUser() {
    sudo $(history -p \!\!)
}
alias fuck='__executeLastCommandAsSuperUser'
alias fu='__executeLastCommandAsSuperUser'
alias f='__executeLastCommandAsSuperUser'

# Runs cp as superuser in interactive mode (asks before it overwrites
# anything).
__copyFilesSafelyAsSuperUser() {
    sudo cp --interactive --verbose "$@"
}
alias scp='__copyFilesSafelyAsSuperUser'

# Runs mv as superuser in interactive mode (asks before it overwrites
# anything).
__moveFilesSafelyAsSuperUser() {
    sudo mv --interactive --verbose "$@"
}
alias smv='__moveFilesSafelyAsSuperUser'

# Runs rm as superuser in interactive mode (asks you for every file, if you
# really want to delete it). Run with -f option to override
# interactive mode.
__deleteFilesSafelyAsSuperUser() {
    sudo rm --interactive "$@"
}
alias srm='__deleteFilesSafelyAsSuperUser'

# Copies whole directory as superuser in interactive mode (asks before it
# overwrites anything).
__copyDirectoriesSafelyAsSuperUser() {
    sudo cp --interactive --verbose --archive --recursive "$@"
}
complete -F _filedir_xspec __copyDirectoriesSafely 
alias scpdir='__copyDirectoriesSafelyAsSuperUser'

# Moves whole directory as superuser in interactive mode (asks before it
# overwrites anything).
__moveDirectoriesSafelyAsSuperUser() {
    sudo mv --interactive --verbose "$@"
}
complete -F _filedir_xspec __moveDirectoriesSafely 
alias smvdir='__moveDirectoriesSafelyAsSuperUser'

# Removes whole directory as superuser in interactive mode (checks for every
# file if you really want to delete it). Run with -f option to
# override interactive mode.
__removeDirectoriesSafelyAsSuperUser() {
    sudo rm --interactive --recursive "$@"
}
alias srmdir='__removeDirectoriesSafelyAsSuperUser'

# TODO add less options
# Runs less as su.
__displayTextInPagerAsSuperUser() {
    sudo less "$@"
}
alias sm='__displayTextInPagerAsSuperUser'

# Runs Vim in read only mode, as superuser
__viewFileInVimAsSuperUser() {
    sudo view "$@"
}
alias svv='__viewFileInVimAsSuperUser'

# Runs Vim as su.
__editFileWithVimAsSuperUser() {
    sudo vim "$@"
}
alias sv='__editFileWithVimAsSuperUser'

# Runs Nano as su.
__editFileWithNanoAsSuperUser() {
    sudo nano -icHFwST 4 "$@"
}
alias sn='__editFileWithNanoAsSuperUser'
 
# Runs Gedit as su.
__editFileWithGeditAsSuperUser() {
    sudo gedit "$@"
}
alias sg='__editFileWithGeditAsSuperUser'


#############
# PROCESESS #
#############

# Shows detailed overview of processes (task manager).
__runTaskManager() {
    htop "$@"
}
alias taskManager='__runTaskManager'
alias ht='__runTaskManager'

# Prints user's processes and sends output to pager if
# necessary.
__printUsersProcesses() {
    ps "$@" | __printOrDisplayTextInPager
}
alias ps1='__printUsersProcesses'

# Prints every process on the system.
__printAllProcesses() {
    ps -e "$@" | __printOrDisplayTextInPager
}
alias processes='__printAllProcesses'
alias pse='__printAllProcesses'
alias psa='__printAllProcesses'

# Prints processes with specified pattern in their names,
# together with their PIDs.
__findProcessesWithPartOfName() {
    pgrep --list-name "$@" | __printOrDisplayTextInPager
}
alias pgrep1='__findProcessesWithPartOfName'

# Sends KILL signal to process with specified PID, instead of
# kill's default signal TERM.
__killProcessWithKillSignal() {
    kill -9 "$@"
}
alias kill1='__killProcessWithKillSignal'

# TODO options
# Traces system calls and signals. Prints strings of maximum
# 2000 characters, and also traces child processes.
__traceSystemCalls() {
    strace -s 2000 -f "$@" 2>&1 | __printAndDisplayTextInPagerIfNecessary 
}
alias trace='__traceSystemCalls'
alias strace1='__traceSystemCalls'
alias st='__traceSystemCalls'


########
# TEXT #
########

# Deletes specified characters.
__deleteCharacters() {
    tr --delete "$@"
}
alias trd='__deleteCharacters'

# Creates table out of input lines (lines up the columns). You
# need to specify the delimiter character.
__lineUpColumns() {
    column -t -s "$@"
}
alias table='__lineUpColumns'

# TODO parameters
# Treats input lines as rows of a table. With second argument
# you specify the columns you want to retain, and with first,
# the delimiter character. For more columns use comma or dash
# (for ranges).
__keepColumns() {
    cut --delimiter="$1" --fields="$2" 
}
alias keepColumns='__keepColumns'
alias cut1='__keepColumns'

# TODO parameters
# Treats input lines as rows of a table and sorts them by column
# you specify with second parameter. First argument specifies
# the delimiter character. Using comma, more columns can be
# specified (in order of importance).
__sortLinesByColumn() { 
    sort --field-separator="$1" --key="$2"
}
alias sort1='__sortLinesByColumn'


##########
# SEARCH #
##########

# TODO options
# Runs grep with highlighting matches, not grepping through .svn
# and .git folders, using Perl regex format (it has some
# additional operators, for instance, '+' for matching one or
# more times) and ignoring case.
__printLinesContainingPattern() {
    grep --color=auto --exclude-dir=\.svn --exclude-dir=\.git \
        --ignore-case --perl-regexp "$@"
}
alias grep1='__printLinesContainingPattern'

# Runs __printLinesContainingPattern and sends output to pager.
__printOrDisplayWithPagerLinesContainingPattern() {
    __printLinesContainingPattern --color=always "$@" \
        | __printOrDisplayTextInPager
}
alias gr='__printOrDisplayWithPagerLinesContainingPattern'

# TODO doesent work, probably because gr uses different regex, so argument needs to be stripped of *.
# Tries to find specified file using index. (Run 'sudo updatedb'
# to update the index)
__locateFilesContainingPatternInTheirNamesGlobaly() {
    locate "$1" | __printOrDisplayWithPagerLinesContainingPattern $(echo "$1" | tr -d "\*")
}
alias locate1='__locateFilesContainingPatternInTheirNamesGlobaly'
alias lo='__locateFilesContainingPatternInTheirNamesGlobaly'

# Searches for files containing pattern in their names in
# current and sub-directories.  Use filesystem regexes for
# search (aka *.*), and always surround them with quotation
# marks. Also highlights the matches.
__locateFilesContainingPatternInTheirNamesInWorkingAndSubDirs() {
    find . -name "$1" | __printOrDisplayWithPagerLinesContainingPattern $(echo "$1" | tr -d "\*")
}
alias find1='__locateFilesContainingPatternInTheirNamesInWorkingAndSubDirs'

# Prints all directories in current and sub-directories.
__printAllSubdirectories() {
	find . -name .git -prune -o -type d | __printOrDisplayTextInPager
}
alias directories='__printAllSubdirectories'
alias findd='__printAllSubdirectories'


############
# ARCHIVES #
############

# Extracts archive of any type. (Author (Vitalii
# Tereshchuk)[https://github.com/xvoland])
__extractArchiveOfAnyType() {
    if [ -z "$1" ]; then
        # display usage if no parameters given
        echo -n "Usage: extract <path/file_name>"
        echo -n ".<zip|rar|bz2|gz|tar|tbz2|tgz|Z|"
        echo "7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    else
        if [ -f "$1" ] ; then
            NAME=${1%.*}
            #mkdir $NAME && cd $NAME
            case "$1" in
                *.tar.bz2)   tar xvjf ./"$1"    ;;
                *.tar.gz)    tar xvzf ./"$1"    ;;
                *.tar.xz)    tar xvJf ./"$1"    ;;
                *.lzma)      unlzma ./"$1"      ;;
                *.bz2)       bunzip2 ./"$1"     ;;
                *.rar)       unrar x -ad ./"$1" ;;
                *.gz)        gunzip ./"$1"      ;;
                *.tar)       tar xvf ./"$1"     ;;
                *.tbz2)      tar xvjf ./"$1"    ;;
                *.tgz)       tar xvzf ./"$1"    ;;
                *.zip)       unzip ./"$1"       ;;
                *.Z)         uncompress ./"$1"  ;;
                *.7z)        7z x ./"$1"        ;;
                *.xz)        unxz ./"$1"        ;;
                *.exe)       cabextract ./"$1"  ;;
                *)           echo "extract: '$1' - unknown archive method" ;;
            esac
        else
            echo "'$1' - file does not exist"
        fi
    fi
}
alias extract='__extractArchiveOfAnyType'


########
# TMUX #
########

# Runs Tmux.
__runTerminalMultiplexer() {
    tmux "$@"
}
alias tm='__runTerminalMultiplexer'

# Runs Tmux, and attaches to last session.
__runTerminalMultiplexerAndAttachToSession() {
    tmux attach "$@"
}
alias tma='__runTerminalMultiplexerAndAttachToSession'

# Lists all running Tmux sessions.
__printTerminalMultiplexersSessions() {
    tmux ls
}
alias tml='__printTerminalMultiplexersSessions'


######################
# SYSTEM INFORMATION #
######################

# Reports disk space of main partitions in human readable form.
__printDiskSpaceUsageInSimplifiedForm() {
    df -h | grep "sd\|Size" | cat
}
alias df1='__printDiskSpaceUsageInSimplifiedForm'

# Displays disk space used by a folder or a file in human
# readable form.
__printDiskUsageOfFileOrFolder() {
    du --summarize --human-readable "$@"
}
alias du1='__printDiskUsageOfFileOrFolder'

# Prints all and free memory in megabytes.
__printMemoryStatusInSimplifiedForm() {
    echo "all:  "$(free -m \
        | grep Mem \
        | sed 's/^Mem: *\([0-9]*\).*/\1/')" MB"
    echo "free: "$(free -m \
        | grep Mem \
        | sed 's/^[^ ]*[ ]*[^ ]*[ ]*[^ ]*[ ]*\([^ ]*\)[ ]*[^ ]*[ ]*[^ ]*[ ]*[^ ]*/\1/')" MB"
}
alias free1='__printMemoryStatusInSimplifiedForm'
alias fr='__printMemoryStatusInSimplifiedForm'

# Displays CPU's temperature.
__printTemperatureOfCpu() {
    acpi -t
}
alias temperature='__printTemperatureOfCpu'
alias temp='__printTemperatureOfCpu'

# Prints battery status.
__printBatteryStatus() {
    acpi
}
alias battery='__printBatteryStatus'
alias batt='__printBatteryStatus'

# Prints kernel version and Linux distribution.
# todo: sed
__printOperatingSystemInformation() {
    uname --all
}
alias kernelVersion='__printOperatingSystemInformation'
alias uname1='__printOperatingSystemInformation'

# Prints verbose information about all PCI devices. 
__printInfoAboutPciDevices() {
    lspci -v "$@" | __printOrDisplayTextInPager
}
alias lspci1='__printInfoAboutPciDevices'
alias pci='__printInfoAboutPciDevices'


#########
# POWER #
#########
 
# TODO research
# Restarts computer.
__restartComputer() {
    sudo shutdown -r now
}
alias restart='__restartComputer'

# Shuts down computer.
__shutDownComputer() {
    sudo shutdown now
}
alias poweroff='__shutDownComputer'

# Hibernates.
__hibernateComputer() {
    sudo pm-hibernate
}
alias hib='__hibernateComputer'

# Suspends.
__suspendComputer() {
    sudo pm-suspend
}
alias sus='__suspendComputer'


############
# KEYBOARD #
############

# Sets keyboard layout to us layout.
__changeKeyboardLayoutToAmerican() {
    setxkbmap -layout us "$@"
}
alias uskeys='__changeKeyboardLayoutToAmerican'

# Gets keycode of pressed key.
__moniterKeycodesOfPressedKeys() {
    xev "$@"
}
alias keycode='xev'

# Turns key input repeat off.
__turnOffKeyRepeat() {
    xset -r
}
alias norepeat='__turnOffKeyRepeat'

# Turns key input repeat on.
__turnOnKeyRepeat() {
    xset r
}
alias repeat='__turnOnKeyRepeat'


########
# MISC #
########

# Changes the hue of default blue color in Linux terminal (tty),
# that is otherwise hard to read.
__changeHueOfColorBlueInLinuxTerminal() {
    echo -en "\e]PC7373C9"
}
alias blue='__changeHueOfColorBlueInLinuxTerminal'

# Prints PATH variable, each entry in its own line.
__printDirectoriesContainedByPathVariable() {
    echo -e ${PATH//:/\\n}
}
alias path='__printDirectoriesContainedByPathVariable'

# Runs console calculator with decimal numbers.
__runDecimalCalculator() {
    gcalccmd "$@"
}
alias bc1='__runDecimalCalculator'

# Prints hexadecimal representation of file or piped stream.
__printHexadecimalRepresentationOfFileOrStream() {
    hd "$@" | __printOrDisplayTextInPager
}
alias hd1='__printHexadecimalRepresentationOfFileOrStream'

# Trims SSD disk.
__trimSsd() {
	sudo fstrim -v /
}
alias ssd='__trimSsd'

# Sets bash to vi mode.
__changeBashLineEditingToViMode() {
    set -o vi
}
alias vimode='__changeBashLineEditingToViMode'

# Sets bash to emacs (normal) mode.
__changeBashLineEditingToEmacsMode() {
    set -o emacs
}
alias emacsmode='__changeBashLineEditingToEmacsMode'

# Runs profile script.
__runProfileScript() {
    source /etc/profile
}
alias profile='__runProfileScript'

# Runs a typing tutor.
__startTypingTutor() {
    gtypist "$@"
}
alias tt='__startTypingTutor'

# Counts number of lines in files with specified extension 
# in current and sub-directories.
# $1 - file extension
__countLinesInFilesWithExtensionInWorkingAndSubdirectories() {
    rootDir="$PWD"
    no=0
    for file in *; do
        if [ -d "$file" ]; then
            #echo "entering $file" >&2
            cd "$file"
            recRes=`linesOfCode "$1"`
            #echo "recRes is $recRes" >&2
            let no=$no+"$recRes"
            cd "$rootDir"
        fi
        if [[ "$file" == *."$1" ]]; then
            let no=$no+`cat "$file" | wc -l`    
        fi
    done
    echo $no
}
alias linesOfCode='__countLinesInFilesWithExtensionInWorkingAndSubdirectories'
alias loc='__countLinesInFilesWithExtensionInWorkingAndSubdirectories'


######################
# PACKAGE MANAGEMENT #
######################

# Installs package.
__installPackage() {
    sudo apt-get install "$@"
}
alias canhaz='__installPackage'
alias ch='__installPackage'

# Updates package information.
__updatePackageInfo() {
    sudo apt-get update
}
alias update='__updatePackageInfo'

# Upgrades all packages to newest available version.
__upgradeAllPackages() {
    sudo apt-get upgrade
}
alias upgrade='__upgradeAllPackages'

# Tries to upgrade all packages. If any dependency conflicts
# arise, then it handles them intelligently, by upgrading the
# most important packages at the expense of less important ones.
__upgradeAllPackagesIntelligently() {
    sudo apt-get dist-upgrade
}
alias dist-upgrade='__upgradeAllPackagesIntelligently'

# Removes package and all the packages this package dependent on
# and were only used by this package.
__removePackage() {
    sudo apt-get remove "$@" && __removeUnneededPackages
}
alias remove='__removePackage'

# Removes package, together with its configuration files. All
# the packages this package dependent on and were only used by
# this package are also removed.
__removePackageAndAllItsConfigurations() {
    sudo apt-get purge "$@" && __removeUnneededPackages
}
alias purge='__removePackageAndAllItsConfigurations'

# Removes packages that were automatically installed to satisfy
# dependencies for other packages and are now no longer needed.
__removeUnneededPackages() {
    sudo apt-get autoremove
}
alias autoremove='__removeUnneededPackages'


#######################
# PACKAGE INFORMATION #
#######################

# Prints package description.
__printPackageDescription() {
    apt-cache show "$@" | grep "^ " | __printOrDisplayTextInPager
}
alias describe='__printPackageDescription'
alias pd='__printPackageDescription'

# Returns 0 if package is instaled, or non-zero if not.
__isPackageInstalled() {
    dpkg -s "$@" &> /dev/null
    return "$?"
}

# Prints installed and remote version of package.
__printPackagesInstalledAndAvailableVersion() {
    versionInfo=$(apt-cache policy "$@")
    echo "$versionInfo" | grep Installed | sed 's/^ *//'
    echo "$versionInfo" | grep Candidate | sed 's/^ *//'
}

# Shows on which packages specified package depends.
__printPackageDependencies() { 
    apt-cache show "$@" \
        | grep Depends \
        | sed 's/Depends:/ /' \
        | sed 's/,/\n /g' \
        | __printOrDisplayTextInPager
}
alias depends='__printPackageDependencies'

# Prints packages that were installed by the user, in order of
# installation.
__printPackagesThatWereInstalledByUser() {
    cat /var/log/apt/history.log \
        | grep "apt-get install" \
        | sed "s/.* //" \
        | __printOrDisplayTextInPagerStartingAtEnd
}
alias packages='__printPackagesThatWereInstalledByUser'
alias installed='__printPackagesThatWereInstalledByUser' 

# Prints all installed packages.
__printInstalledPackages() {
    dpkg --get-selections \
        | grep -v deinstall \
        | __printOrDisplayTextInPager
}
alias allPackages='__printInstalledPackages'
alias allInstalled='__printInstalledPackages'


##########################
# PACKAGE/COMMAND SEARCH #
##########################

# Runs apropos, a command that finds installed commands, with
# provided pattern in their names or descriptions. Matches get
# highlighted.
__findInstalledCommandsWithPartOfNameOrDescription() {
    apropos "$@" \
        | __printOrDisplayWithPagerLinesContainingPattern  "$@"
}
alias findCommand='__findInstalledCommandsWithPartOfNameOrDescription'
alias apropos1='__findInstalledCommandsWithPartOfNameOrDescription'
alias ap='__findInstalledCommandsWithPartOfNameOrDescription'

# Searches packages, that can be installed with apt-get. Search
# is performed on their names and short descriptions.
__findAvailablePackagesWithPartOfNameOrDescription() {
    apt-cache search "$@" \
        | __printOrDisplayWithPagerLinesContainingPattern  "$@"
}
alias findPackage='__findAvailablePackagesWithPartOfNameOrDescription'

# Searches packages, that can be installed with apt-get. Search
# is performed only on their names.
__findAvailablePackagesWithPartOfName() {
    apt-cache search "$1" \
        | __printLinesContainingPattern "^[^ ]*$1[^ ]*" \
        | __printOrDisplayWithPagerLinesContainingPattern "$1" 
}

# Finds which available packages provide specified command.
__findAvailablePakagesThatProvideCommand() {
    apt-file search "$1" \
        | grep \/bin\/"$1"$ \
        | __printOrDisplayWithPagerLinesContainingPattern "^.*:"
}
alias apt-file1='__findAvailablePakagesThatProvideCommand'

# Finds which available packages contain specified file or have
# the pattern in their names.
__findAvailablePackagesWithPartOfNameOrFullCommand() {
    (echo   "PACKAGES PROVIDING COMMAND NAMED \"$1\""
    echo -n "==================================="
    echo "$1" | sed 's/./=/g'
    __findAvailablePakagesThatProvideCommand "$@"
    echo -e "\nPACKAGES CONTAINING \"$@\" IN THEIR NAMES"   
    echo -n   "====================================="
    echo "$1" | sed 's/./=/g'
    __findAvailablePackagesWithPartOfName "$@") \
        | __printAndDisplayTextInPagerIfNecessary 
}

# Find which installed package provides specified command.
__printInstalledPackageThatProvidesCommandAndItsLocation() {
    file=$(sudo which "$1")
    if [ "$file" == "" ]; then 
        return
    fi  
    resolved=$(readlink -f "$file")
    dpkg -S "$resolved" \
        | __printLinesContainingPattern "^.*:"
}

# Prints installed and remote version of package or command (that is part of package).
__printVersionOfPackageOrCommand() {
    __isPackageInstalled "$@"
    if [[ $? -eq 0 ]]; then
        __printPackagesInstalledAndAvailableVersion "$@"
    else
        packageInfo=$(__printInstalledPackageThatProvidesCommandAndItsLocation "$@")
        packageName=$(echo "$packageInfo" | sed 's/:.*$//')
        echo "Package:   $packageName"
        __printPackagesInstalledAndAvailableVersion "$packageName"
    fi
}
alias version='__printVersionOfPackageOrCommand'
alias ve='__printVersionOfPackageOrCommand'

__printAliasDefinition() {
    type "$@" 
}

# Converts man section number into a description.
__getManSectionNameFromNumber() {
    case "$1" in
        1)      echo "user command"                     ;;
        2)      echo "system call"                      ;;
        3)      echo "c function"                       ;;
        4)      echo "device file"                      ;;
        5)      echo "file format or convention"        ;;
        6)      echo "game"                             ;; 
        7)      echo "miscallaneous"                    ;;
        8)      echo "su command"                       ;;
        9)      echo "kernel routine"                   ;;
    esac
}

# If command is available then it prints it's description, package and
# location.
__printInfoAboutInstalledCommand() {
    call1=$(sudo whatis "$@" 2> /dev/null)
    if [ "$?" == "0" ]; then 
        while IFS= read -r line; do
            commandType=$(__getManSectionNameFromNumber $(echo "$line" | sed 's/.*(\([1-9]\)).*/\1/'))
            echo "$line" "($commandType)"
        done <<< "$call1"
        echo -n "Package:   "
        packageInfo=$(__printInstalledPackageThatProvidesCommandAndItsLocation "$@")
        echo "$packageInfo" | sed 's/: /\nLocation:  /'
        return 0
    fi
    return 1
}
alias package='__printInfoAboutInstalledCommand'

# Universal command description search function. First tries
# whatis, then apt-cache show, then type and finally apt-file.
# When one of them succeeds in finding the description the
# function returns.
__findPackageOrCommandWithPatternInItsName() {
    # Checks if it is an installed command.
    __printInfoAboutInstalledCommand "$@"
    if [ "$?" == "0" ]; then 
        return
    fi

    # Checks if it is a package.
    call2=$(__printPackageDescription "$@" 2> /dev/null) 
    if [ "$call2" != "" ]; then
        echo "$call2" | __printOrDisplayTextInPager
        return
    fi

    # Checks if it is an alias.
    call3=$(__printAliasDefinition "$@" 2> /dev/null)
    if [ "$call3" != "" ]; then
        echo "$call3"
        return
    fi

    # Search all available commands and packages with part of the
    # name.
    __findAvailablePackagesWithPartOfNameOrFullCommand "$@" 
}
alias whatis1='__findPackageOrCommandWithPatternInItsName'
alias wi='__findPackageOrCommandWithPatternInItsName'


#######
# GIT #
#######

# Commits changed and deleted files. Commit message must be
# entered as parameter.
__commitChangedAndDeletedFilesWithMessage() {
    git commit -am "$@"
}
alias commit='__commitChangedAndDeletedFilesWithMessage'

# Commits changed and deleted files. Opens text editor, so
# proper commit message can be entered.
__commitChangedAndDeletedFiles() {
    git commit -a "$@"
}
alias commitm='__commitChangedAndDeletedFiles'

# Creates an empty Git repository or reinitializes an existing
# one (nondestructive).
__initializeRepository() {
    git init "$@"
}
alias init='__initializeRepository'

# Pushes changes to remote repository.
__pushChangesToRemoteRepository() {
    git push "$@"
}
alias push='__pushChangesToRemoteRepository'

# Pulls changes from remote repository.
__pullChangesFromRemoteRepository() {
    git pull "$@"
}
alias pull='__pullChangesFromRemoteRepository'

# Joins specified branch with current one.
__mergeSpecifiedBranchWithCurrentOne() {
    git merge "$@"
}
alias merge='__mergeSpecifiedBranchWithCurrentOne'

# Switches to another branch, or checks-out a file from
# repository.
__checkoutBranchOrFile() {
    git checkout "$@"
}
alias checkout='__checkoutBranchOrFile'
alias gc='__checkoutBranchOrFile'

# Prints all branches, or creates new one, if name is specified. 
__printBranchesOrCreateNewOne() {
    git branch "$@"
}
alias branch='__printBranchesOrCreateNewOne'
alias gb='__printBranchesOrCreateNewOne'

# Prints short status of repository.
__printRepositoryStatus() {
    git -c color.status=always status -sb "$@" | __printOrDisplayTextInPager
}
alias gs='__printRepositoryStatus'

# Prints nicely decorated graph of commits, with commit
# messages, full hashes and full dates. 
__displayLogOfCommits() {
    git log --decorate --graph --all "$@"
}
alias gl='__displayLogOfCommits'

# Prints nicely decorated graph of commits, with only first
# lines of commit messages, shortened hashes and full dates.
__displayMinimalLogOfCommits() {
    git log --graph --abbrev-commit --decorate \
        --format=format:'%C(bold blue)%h%C(reset) \
        - %C(bold cyan)%aD%C(reset) \
        %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' \
        %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all
}
alias gl1='__displayMinimalLogOfCommits'

# Updates information about state of the remote repository and
# prints status.
__updateInfoAboutRemoteRepositoryAndPrintStatus() {
    git remote update "$@"
    __printRepositoryStatus
}
alias gu='__updateInfoAboutRemoteRepositoryAndPrintStatus'

# Shows changes between commits. If no parameter is given, then
# shows changes between last commit and current state.
__displayChangesBetweenCommits() {
    git diff "$@"
}
alias gd='__displayChangesBetweenCommits'

# Adds file to repository.
__addFileToRepository() {
    git add "$@"
}
alias ga='__addFileToRepository'

# Moves file or directory. Git will in most cases recognize that
# files were moved even if regular 'mv' command was used, but
# this way it is for shure.
__moveRepositoriesFiles() {
    git mv "$@"
}
alias gm='__moveRepositoriesFiles'

# Prints files that are in repository.
__printFilesThatAreInRepository() {
    git ls-files "$@"
}
alias lsgit='__printFilesThatAreInRepository'
alias gls='__printFilesThatAreInRepository'


##########
# GITHUB #
##########

# Clones project from Github. User and project names must be
# specified as <user>/<project>.
__cloneGithubProject() {
    git clone git@github.com:/"$1".git
}
alias clone='__cloneGithubProject'

# Sets remote repository to specified Github project. Repository
# must be entered as <user>/<project>.
__setGithubProjectAsRemoteRepository() {
    git remote add origin git@github.com:/"$1".git
    git pull origin master
    git push origin master
}
alias origin='__setGithubProjectAsRemoteRepository'

# Clones all users Github projects in working directory.
__cloneAllUsersGithubProjects() {
    if [[ -z "$1" ]]; then
        exit
    fi
    tempFile=`mktemp`
    wget 'https://github.com/gto76?tab=repositories' -O "$tempFile"
    repos=$(grep "$1"/[^//\"]* -o "$tempFile" \
        | sort -u \
        | grep -v follow)
    while read -r line; do
        git clone git@github.com:"$line"
    done <<< "$repos"
}
alias cloneAll='__cloneAllUsersGithubProjects'


###########
# NETWORK #
###########

# Prints internal ip.
__printInternalIp() {
    /sbin/ifconfig \
        | grep "inet addr:192.168" \
        | grep -o addr:[0-9.]* \
        | grep -o [0-9.]\* \
        | cat 
}
alias ip1='__printInternalIp'

# Prints external ip. 
__printExternalIp() {
    lynx --dump http://ipecho.net/plain | grep -o [0-9.]\*
}
alias ip2='__printExternalIp'

# Prints gateways ip.
__printGatewaysIp() {
    route -n \
        | grep "192.168." \
        | head -n1 \
        | grep -o "192.168.[0-9.]*"
}
alias gateway='__printGatewaysIp'

# Prints mac addresses of local devices.
__printMacAdressesOfLocalDevices() {
    ifconfig | grep HWaddr | cat
}
alias mac='__printMacAdressesOfLocalDevices'

# Pings gateway, ip address of noip.com and www.google.com.
__pingGatewayIpAndGoogle() {
    ping -c 1 -q `gateway` | grep --color=never -A 1 statistics
    ping -c 1 -q 8.23.224.107 | grep --color=never -A 1 statistics
    ping -c 1 -q www.google.com | grep --color=never -A 1 statistics
}
alias pingAll='__pingGatewayIpAndGoogle'
alias pa='__pingGatewayIpAndGoogle'

# Scans addresses of local network. If a number is specified it
# scans local addresses up to this number (0-255).
__scanLocalNetwork() {
    if [[ $# -eq 0 ]]; then
        third=$(ip1 \
            | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta')
        forth="254"
    fi
    if [[ $# -eq 1 ]]; then
        third=$(ip1 \
            | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta')
        forth="$1"
    fi
    if [[ $# -gt 1 ]]; then
        third="$1"
        forth="$2"
    fi
    nmap -sP 192.168."$third".0-"$forth"
}
alias nmap1='__scanLocalNetwork'

# Prints 'OK' if specified address or ip can be reached with
# ping, or 'Fail' if not.
__isAddressReachable() {
    pingResult=$(
        ping -c 1 -q "$1" \
            | grep --color=never -A 1 statistics \
            | grep "1 received")
    if [ "$pingResult" != "" ]; then
        echo -n "OK"
    else
        echo -n "Fail"
    fi
}

# Prints status of the ssh port of the specified host.
__printStatusOfSshPortAtAddress() {
    nmap $(echo "$1" | tr -d ' ') -p22 \
        | grep '22/tcp' \
        | sed 's/^[^ ]* \([^ ]*\) .*$/\1/'
}

# Scans first 20 addresses of local network and prints yours,
# gateways and the ip-s of other connected devices. Also checks
# their ssh port status.  After that checks checks if connection
# to the internet is available by pinging Google and ip address
# of noip.com.
__printNetworkStatus() {
    localIp=$(ip1)
    gateway=$(gateway)
    echo "You:      $localIp   ssh: $(__printStatusOfSshPortAtAddress $(ip2))"
    echo "Gateway:  $gateway    ssh: $(__printStatusOfSshPortAtAddress "$gateway")"
    all=$(nmap1 20)
    allFiltered=$(
        echo "$all" | 
        grep -v "$localIp" |
        grep -v "$gateway" |
        grep -o "[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*" |
        sed 's/^/          /g' ) 
    len=${#allFiltered} 
    allFiltered=${allFiltered:6:len-6} 
    echo -n "Other:"

    while IFS= read -r line; do 
        echo -n "$line    ssh: "
        __printStatusOfSshPortAtAddress "$line"    
    done <<< "$allFiltered"

    testIp="8.23.224.107"
    echo "Internet: $testIp   Ping: $(__isAddressReachable "$testIp")"
    testDomain="www.google.com"
    echo "          $testDomain Ping: $(__isAddressReachable "$testDomain")"
}
alias network='__printNetworkStatus'
alias ne='__printNetworkStatus'


############
# WIRELESS #
############

# Disables wireless device.
__blockWirelessDevice() {
    sudo rfkill block $(
        sudo rfkill list \
            | grep Wireless \
            | grep ^[0-9] -o)
}
alias woff='__blockWirelessDevice'

# Enables wireless device.
__unblockWirelessDevice() {
    sudo rfkill unblock $(
        sudo rfkill list \
            | grep Wireless \
            | grep ^[0-9] -o)
}
alias won='__unblockWirelessDevice'

# Resets wireless device.
__resetWirelessDevice() {
    woff
    won
}
alias wr='__resetWirelessDevice'

# Activates wireless interface (driver).
__activateWirelessInterface() {
    sudo ifconfig wlan0 up
}
alias up='__activateWirelessInterface'

# Shuts down wireless interface (driver).
__deactivateWirelessInterface() {
    sudo ifconfig wlan0 down
}
alias down='__deactivateWirelessInterface'

# Displays wireless networks in range.
__printWirelessNetworksInRange() {
    sudo iwlist wlan0 scan \
        | grep Quality -A2 \
        | tr -d "\n" \
        | sed 's/--/\n/g' \
        | sed -e 's/ \+/ /g' \
        | sort -r \
        | sed 's/ Quality=//g' \
        | sed 's/\/70 Signal level=-[0-9]* dBm Encryption key:/ /g' \
        | sed 's/ ESSID:/ /g'
}
alias wlan='__printWirelessNetworksInRange'


############
# INTERNET #
############

# Runs default browser in background.
__startDefaultBrowserInBackground() {
    __runCommandInBackground sensible-browser "$@"
}
alias internet='__startDefaultBrowserInBackground'
alias i='__startDefaultBrowserInBackground'

# Runs Firefox in background.
__startFirefoxInBackground() {
    __runCommandInBackground firefox "$@"
}
alias fire='__startFirefoxInBackground'

# Runs Chrome in background with setting that resolves some bug
# in some cases (it is probably already fixed).
__startChromeInBackground() {
    __runCommandInBackground google-chrome --touch-devices=123
}
alias chrome='__startChromeInBackground'

# Runs Lynx that accepts all cookies, starts in Google and is
# using Vim mode for navigation.
__startLynx() {
    lynx -accept_all_cookies -vikeys www.google.com "$@"
}
alias lynx1='__startLynx'


#########
# AUDIO #
#########

# Control volume of all audio channels.
__startConsoleAudioMixer() {
    alsamixer "$@"
}
alias mixer='__startConsoleAudioMixer'

# Set master volume in rage of 0 to 100.
__setVolumeTo() {
    amixer set Master playback "$1"
}

# Increases volume by 6dB.
__increaseVolumeBy6Db() {
    __setVolumeTo "6%+" | tail -n 1
}
alias a='__increaseVolumeBy6Db'

# Decreases volume by 6dB.
__decreaseVolumeBy6Db() {
    __setVolumeTo "6%-" | tail -n 1
}
alias z='__decreaseVolumeBy6Db'

# Increases volume by 2dB.
__increaseVolumeBy2Db() {
    __setVolumeTo "2%+" | tail -n 1
}
alias aa='__increaseVolumeBy2Db'

# Decreases volume by 2dB.
__decreaseVolumeBy2Db() {
    __setVolumeTo "2%-" | tail -n 1
}
alias zz='__decreaseVolumeBy2Db'


###############
# COMPLETIONS #
###############

# Calling python function
completionDefsForAliases=$(/home/minerva/github/standard-aliases/getComletionFunction.py "$(alias)" "$(complete)")
eval "$completionDefsForAliases"
#echo "$completionDefsForAliases"


# Automatically add completion for all aliases to commands having completion functions
function alias_completion {
    local namespace="alias_completion"

    # parse function based completion definitions, where capture group 2 => function and 3 => trigger
    local compl_regex='complete( +[^ ]+)* -F ([^ ]+) ("[^"]+"|[^ ]+)'
    # parse alias definitions, where capture group 1 => trigger, 2 => command, 3 => command arguments
    local alias_regex="alias ([^=]+)='(\"[^\"]+\"|[^ ]+)(( +[^ ]+)*)'"

    # create array of function completion triggers, keeping multi-word triggers together
    eval "local completions=($(complete -p | sed -Ene "/$compl_regex/s//'\3'/p"))"
    (( ${#completions[@]} == 0 )) && return 0

    # create temporary file for wrapper functions and completions
    rm -f "/tmp/${namespace}-*.tmp" # preliminary cleanup
    local tmp_file; tmp_file="$(mktemp "/tmp/${namespace}-${RANDOM}XXX.tmp")" || return 1

    local completion_loader; completion_loader="$(complete -p -D 2>/dev/null | sed -Ene 's/.* -F ([^ ]*).*/\1/p')"

    # read in "<alias> '<aliased command>' '<command args>'" lines from defined aliases
    local line; while read line; do
        eval "local alias_tokens; alias_tokens=($line)" 2>/dev/null || continue # some alias arg patterns cause an eval parse error
        local alias_name="${alias_tokens[0]}" alias_cmd="${alias_tokens[1]}" alias_args="${alias_tokens[2]# }"

        # skip aliases to pipes, boolan control structures and other command lists
        # (leveraging that eval errs out if $alias_args contains unquoted shell metacharacters)
        eval "local alias_arg_words; alias_arg_words=($alias_args)" 2>/dev/null || continue
        # avoid expanding wildcards
        read -a alias_arg_words <<< "$alias_args"

        # skip alias if there is no completion function triggered by the aliased command
        if [[ ! " ${completions[*]} " =~ " $alias_cmd " ]]; then
            if [[ -n "$completion_loader" ]]; then
                # force loading of completions for the aliased command
                eval "$completion_loader $alias_cmd"
                # 124 means completion loader was successful
                [[ $? -eq 124 ]] || continue
                completions+=($alias_cmd)
            else
                continue
            fi
        fi
        local new_completion="$(complete -p "$alias_cmd")"

        # create a wrapper inserting the alias arguments if any
        if [[ -n $alias_args ]]; then
            local compl_func="${new_completion/#* -F /}"; compl_func="${compl_func%% *}"
            # avoid recursive call loops by ignoring our own functions
            if [[ "${compl_func#_$namespace::}" == $compl_func ]]; then
                local compl_wrapper="_${namespace}::${alias_name}"
                    echo "function $compl_wrapper {
                        (( COMP_CWORD += ${#alias_arg_words[@]} ))
                        COMP_WORDS=($alias_cmd $alias_args \${COMP_WORDS[@]:1})
                        (( COMP_POINT -= \${#COMP_LINE} ))
                        COMP_LINE=\${COMP_LINE/$alias_name/$alias_cmd $alias_args}
                        (( COMP_POINT += \${#COMP_LINE} ))
                        $compl_func
                    }" >> "$tmp_file"
                    new_completion="${new_completion/ -F $compl_func / -F $compl_wrapper }"
            fi
        fi

        # replace completion trigger by alias
        new_completion="${new_completion% *} $alias_name"
        echo "$new_completion" >> "$tmp_file"
    done < <(alias -p | sed -Ene "s/$alias_regex/\1 '\2' '\3'/p")
    source "$tmp_file" && rm -f "$tmp_file"
}; #alias_completion
