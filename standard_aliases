#!/bin/bash

#    _               _              _ _                     
#   | |__   __ _ ___| |__      __ _| (_) __ _ ___  ___  ___ 
#   | '_ \ / _` / __| '_ \    / _` | | |/ _` / __|/ _ \/ __|
#  _| |_) | (_| \__ \ | | |  | (_| | | | (_| \__ \  __/\__ \
# (_)_.__/ \__,_|___/_| |_|   \__,_|_|_|\__,_|___/\___||___/
#


########
# LESS #
########

# Runs less with a few sensible options.
#   * ignore case when searching, 
#   * do not ring a bell,
#   * do not mark empty lines with ~, 
#   * format prompt as "<page-number>/<all-pages> <filename>",
#   * set tabs to 4 spaces.
lessWithSensibleOptions() {
    less --ignore-case --QUIET --tilde -P"%db/%D %f" --tabs=4 "$@"
}
alias less1='lessWithSensibleOptions'
alias le='lessWithSensibleOptions'

# Runs cat or less, depending on number of lines in file or
# input.
catOrLess() {
    if [[ "$#" -gt 0 ]]; then
        noOfLines=$(cat "$1" 2>/dev/null \
            | fold -w"$COLUMNS" \
            | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            cat "$1"
        else
            lessWithSensibleOptions "$1" 2>/dev/null 
        fi
    else
        input=$(cat)
        noOfLines=$(echo "$input" | fold -w"$COLUMNS" | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            echo "$input" | cat 
        else
            echo "$input" | lessWithSensibleOptions 2>/dev/null 
        fi
    fi
}
alias m='catOrLess'

# Open cat or less +G (starts at the end of file), depending on
# no of lines of file or input.
catOrLessG() {
    if [[ "$#" -gt 0 ]]; then
        noOfLines=$(cat "$1" 2>/dev/null \
            | fold -w"$COLUMNS" \
            | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            cat "$1"    
        else
            cat "$1" | lessWithSensibleOptions +G 2>/dev/null
        fi
    else
        input=$(cat)
        noOfLines=$(echo "$input" | fold -w"$COLUMNS" | wc -l)
        if [[ "$LINES" -gt "$noOfLines" ]]; then
            echo "$input" | cat 
        else
            echo "$input" | lessWithSensibleOptions +G 2>/dev/null
        fi
    fi
}


######
# LS #
######

# All other ls aliases end up calling this one. It runs ls with:
#   * append indicator, 
#   * sort alphabetically by extension, 
#   * list by columns, 
#   * use color when stdout is connected to terminal, 
#   * group directories before files.
lsWithSensibleOptions() {
    ls --classify -X -C --color=auto --group-directories-first "$@"
}

# Calls lsWithSensibleOptions with: 
#   * set width to screen width or 69, whichever is smaller.
lsShortCat() {
    width=$(
        widthLimit=69
        if [[ "$COLUMNS" -lt "$widthLimit" ]]; then 
            echo "$COLUMNS"
        else 
            echo "$widthLimit"
        fi)
    lsWithSensibleOptions --width="$width" "$@"
}

# Calls lsWithSensibleOptions with: 
#   * use long listing format, 
#   * do not print groups,
#   * do not list owner, 
#   * print sizes in human readable format, 
#   * print date as: '<month-by-word>, <day-of-month>, <year>,
#   <hour>:<minute>'.
lsMedCat() {
   lsWithSensibleOptions -l --no-group -g --human-readable \
        --time-style="+%b %d %Y %H:%M" "$@"
}

# CallslsWithSensibleOptions with: 
#   * use long listing format. 
lsLongCat() {
   lsWithSensibleOptions -l "$@"
}

# Functions that call aliases above, and pipe output to less.
# They: 
#   * override color option of ls to 'always' and 
#   * pipe output to le with RAW-CONTROL-CHARS option.
# This enables the transfer of colors from ls to less. They also
# start less at end of file.

lsShortLess() { 
    # EX: lsShortCat --color=always $* | lessWithSensibleOptions --RAW-CONTROL-CHARS +G
    lsShortCat --color=always "$@" \
        | lessWithSensibleOptions --RAW-CONTROL-CHARS +G
}

lsMedLess() { 
    lsMedCat --color=always "$@" \
        | lessWithSensibleOptions --RAW-CONTROL-CHARS +G 
}

lsLongLess() { 
    lsLongCat --color=always "$@" \
        | lessWithSensibleOptions --RAW-CONTROL-CHARS +G 
}

# This functions decide weather they will call cat or less
# version of the lstShort/Med/Long function. It depends on
# whether the output of ls will fit on screen.

lsShort() {
    noOfLines=$(
        lsShortCat "$@" 2> /dev/null \
            | fold -w"$COLUMNS" \
            |  wc -l)
    if [[ "$LINES" -gt "$noOfLines" ]]; then
        lsShortCat "$@" 
    else
        lsShortLess "$@" 
    fi
}

lsMed() {
    noOfLines=$(
        lsMedCat "$@" 2> /dev/null \
            | fold -w"$COLUMNS" \
            |  wc -l)
    if [[ "$LINES" -gt "$noOfLines" ]]; then
        lsMedCat "$@"
    else
        lsMedLess "$@"    
    fi
}

lsLong() {
    noOfLines=$(
        lsLongCat "$@" 2> /dev/null \
            | fold -w"$COLUMNS" \
            |  wc -l)
    if [[ "$LINES" -gt "$noOfLines" ]]; then
        lsLongCat "$@"
    else
        lsLongLess "$@"    
    fi
}

# Calls ls (with a lot of options) that lists only names.
alias l='lsShort'

# Calls ls (with a lot of options) that uses shortened long
# listing format.
alias ll='lsMed'

# Calls ls (with a lot of options) that uses long listing
# format.
alias lll='lsLong'

# Calls ls (with a lot of options) that lists only filenames,
# also showing hidden files.
alias la='lsShort --almost-all'

# Calls ls (with a lot of options) that uses shortened long
# listing format, also showing hidden files.
alias lla='lsMed --almost-all'

# Calls ls (with a lot of options) that uses long listing
# format, also showing hidden files.
alias llla='lsLong --almost-all'

# Calls ls (with a lot of options) that lists only names and
# sorts files by date.
alias lt='lsShort -t'

# Calls ls (with a lot of options) that uses shortened long
# listing format and sorts files by date.
alias llt='lsMed -t'

# Calls ls (with a lot of options) that uses long listing format
# and sorts files by date.
alias lllt='lsLong -t'

# Calls ls (with a lot of options) that lists one name per line.
alias l1='lsShort -1'

# Calls ls (with a lot of options) that lists one name per line
# and also shows hidden files.
alias la1='la -1'

# Gets name of first file in the directory.
alias first='ls | head -1'

# Gets name of a random file in the directory.
randomFile() {
    ls "$@" | sort -R | head -1
}
alias rf='randomFile'


########
# TREE #
########

# Displays tree structure of current or specified folder.
treeWithSensibleOptions() {
    tree -C -I .git --dirsfirst "$@" | catOrLess
}
alias tree1='treeWithSensibleOptions'
alias t='treeWithSensibleOptions'


######
# CD #
######

# Simplifies going up in directory hierarchy.
alias cd..='cd ..'
alias ..='cd ..'
alias ,,='cd ..'
alias ...='cd ../..'
alias ,,,='cd ../..'
alias ....='cd ..; cd ..; cd ..;'
alias ,,,,='cd ..; cd ..; cd ..;'
alias .....='cd ..; cd ..; cd ..; cd..'
alias ......='cd ..; cd ..; cd ..; cd..; cd..'
alias .......='cd ..; cd ..; cd ..; cd..; cd..; cd..'

# Mounts ISO file and cd-s into it.
mountIsoAndCdInto() {
    sudo mkdir /media/"$1"
    sudo mount -o loop "$1" /media/"$1"
    cd /media/"$1"
}
alias cdiso='mountIsoAndCdInto'


#########
# FILES #
#########

# Runs cp in interactive mode (asks before it overwrites
# anything).
alias cp='cp -iv'

# Runs mv in interactive mode (asks before it overwrites
# anything).
alias mv='mv -iv'

# Runs rm in interactive mode (asks you for every file, if you
# really want to delete it). Run with -f option to override
# interactive mode.
alias rm='rm -i'

# Copies whole directory in interactive mode (asks before it
# overwrites anything).
alias cpdir='cp -iarv'

# Moves whole directory in interactive mode (asks before it
# overwrites anything).
alias mvdir='mv -iv'

# Removes whole directory in interactive mode (checks for every
# file if you really want to delete it). Run with -f option to
# override interactive mode.
alias rmdir='rm -ir'

# Makes directory (and its parent directories if necessary) and
# descends into.
mkdirAndDescendInto() {
    mkdir -p "$1"
    cd "$1"
}
alias mkdir1='mkdirAndDescendInto'
alias mk='mkdirAndDescendInto'

# Backups file, by making a copy with '.bak' extension. All
# file's attributes are preserved.
backupFile() {
    sudo cp --preserve "$1"{,.bak}
}
alias backup='backupFile'
alias bk='backupFile'

# Switches the contents of two specified files.
switchContentsOfFiles() {
    tempFile=$(mktemp)
    sudo cp "$1" "$tempFile"
    sudo cp -f --no-preserve=mode,ownership "$2" "$1"
    sudo cp -f --no-preserve=mode,ownership "$tempFile" "$2"
}
alias switch='switchContentsOfFiles'


#######
# PWD #
#######

# Prints working directory.
alias .='echo $PWD'

# If no file specified, prints working directory, else full path
# of the file.
printPwdOrPath() {
    if [[ $# -eq 0 ]]; then
        echo "$PWD"
    else
        echo "$PWD"/"$@"
    fi      
}
alias p='printPwdOrPath'


########
# ECHO #
########

# Runs echo.
alias e='echo'

# Runs echo that interprets backslashed characters (\n,...).
alias ee='echo -e'

# Runs echo that doesn't print new line at the end.
alias en='echo -n'


#####################
# RUN IN BACKGROUND #
#####################

# Runs command in background, it doesn't hang up if shell
# is closed and it doesn't print output.
runInBackground() {
    nohup "$@" &>/dev/null &
}
alias rb='runInBackground'


##########
# BASICS #
##########

# Runs bash. Run this command for changes to this file to take
# effect!
alias ba='bash'

# Prints location of specified command, or it's definition, if
# it is an alias. Run this command if you are not shure what an
# alias does!
alias ty='type'

# Runs command as sudo.
alias s='sudo'

# Runs cat.
alias c='cat'

# Prints the exit code of the last command.
alias ?='echo $?'

# Clears the screen.
alias cl='clear'

# Resets the screen.
alias re='reset'

# Exits shell.
alias q='exit'

# Opens file with default application for it's file type.
alias o='runInBackground xdg-open'

# Starts a new terminal, with same working directory. 
alias te='gnome-terminal'

# Runs head (prints first 10 lines of file or piped stream).
alias he='head'

# Prints first line of file or piped stream.
alias he1='head -n1'

# Runs tail (prints last 10 lines of file or piped stream).
alias ta='tail'

# Prints last line of file or piped stream.
alias ta1='tail -n1'

# Counts lines in file or piped stream.
alias wcl='wc -l'

# Counts words in file or piped stream.
alias wcw='wc -w'

# Updates file's timestamp, or creates empty file, if it doesn't
# exits.
alias to='touch'

# Prints current date and time.
alias da='date'

# Runs make and sends both 'out' and 'error' streams to pager if
# necessary.
makeWithPager() {
    make 2>&1 | lessWithSensibleOptions
}
alias make1='makeWithPager'
alias ma='makeWithPager'

# Start Nautilus file explorer in background.
alias na='runInBackground nautilus .'

# Runs diff with colors and sends output to pager if necessary.
diffWithColors() {
    colordiff "$@" | catOrLess
}
alias diff1='diffWithColors'

# Creates executable bash script, or just changes modifiers to
# executable, if file already exists.
makeExecutable() {
    if [[ ! -f "$1" ]]; then
        echo '#!/bin/bash' >> "$1"
        echo '#' >> "$1"
        echo "# Usage: $1 " >> "$1"
        echo '# ' >> "$1"
        echo >> "$1"
        echo '# Uncomment for Strict mode, more info at:' >> "$1"
        echo -n '# http://redsymbol.net/articles/' >> "$1"
        echo 'unofficial-bash-strict-mode' >> "$1"
        echo '# set -euo pipefail' >> "$1"
        echo "# IFS=$'\n\t'" >> "$1"
        echo >> "$1"
    fi
    chmod u+x "$1"        
}
alias me=makeExecutable    


###########
# HISTORY #
###########

# Searches command history for pattern, or if none is specified,
# prints it whole.
grepHistory() {
    if [ "$#" -eq 0 ]; then
        history | catOrLessG
    else
        history | grep "$@" | catOrLessG
    fi
}
alias history1='grepHistory'
alias h='grepHistory'


################
# TEXT EDITORS #
################

# Calls Vim with option that opens one tab per file.
alias v='vim -p'

# Runs Vim in read only mode, and with option that opens one tab
# per file.
alias vv='view -p'

# Runs Nano with a few sensible options.
#   * enable experimental undo (will most probably crash
# if going deeper than first undo level!!!!!!!!!), 
#   * autoindent, 
#   * constantly show the cursor position, 
#   * log search and replace strings,
#   * enable edit of multiple files, 
#   * treat punctuation as part of words, 
#   * smooth scrolling, 
#   * tab size set to 4 spaces.
nanoWithSensibleOptions() {
    nano --undo --autoindent --const --historylog \
        --multibuffer --wordbounds --smooth --tabsize=4
}
alias nano1='nanoWithSensibleOptions'
alias n='nanoWithSensibleOptions'

# Runs Gedit in background.
alias g='runInBackground gedit'

# Runs Sublime Text in background.
alias sub='runInBackground sublime_text'


########
# SUDO #
########

# Alias that puts 'sudo' in front of a command that needs super
# user privileges to run.
# As long as this line of text stays here and is not modified,
# that long all the aliases and functions untill next comment
# will not get documented in README.md.
alias fdisk='sudo fdisk'
alias updatedb='sudo updatedb'
alias ifconfig='sudo ifconfig'
alias tcpdump='sudo tcpdump'
alias route='sudo route'
alias pm-hibernate='sudo pm-hibernate'
alias pm-suspend='sudo pm-suspend'
alias shutdown='sudo shutdown'
alias fstrim='sudo fstrim'
alias apt-get='sudo aptget'
alias iw='sudo iw'
alias nmap='sudo nmap'
alias parted='sudo parted'
alias ntfsundelete='sudo ntfsundelete'
alias lshw='sudo lshw'
alias chown='sudo chown'
alias mount='sudo mount'

# Executes last command as sudo.
executeLastCommandAsSudo() {
    sudo $(history -p \!\!)
}
alias fuck='executeLastCommandAsSudo'
alias fu='executeLastCommandAsSudo'
alias f='executeLastCommandAsSudo'

# Runs cp as su in interactive mode.
alias scp='sudo cp -iv'

# Runs mv as su in interactive mode.
alias smv='sudo mv -iv'

# Runs rm as su in interactive mode (use -f to override
# interactive mode).
alias srm='sudo rm -i'

# Copies whole directory as su in interactive mode.
alias scpdir='sudo cp -arv'

#Moves whole directory as su in interactive mode.
alias smvdir='sudo mv -iv'

# Removes whole directory as su in interactive mode (use -f to
# override interactive mode).
alias srmdir='sudo rm -ir'

# Runs less as su.
alias sm='sudo less'

# Runs Nano as su.
alias sn='sudo nano -icHFwST 4'

# Runs Vim as su.
alias sv='sudo vim'

# Runs Gedit as su.
alias sg='sudo gedit'


#############
# PROCESESS #
#############

# Shows detailed overview of processes.
alias ht='htop'

# Prints user's processes and sends output to pager if
# necessary.
psWithPager() {
    ps "$@" | catOrLess
}
alias ps1='psWithPager'

# Prints every process on the system.
alias pse='psWithPager -e'
alias psa='psWithPager -e'

# Prints processes with specified pattern in their names,
# together with their PIDs.
pgrepWithNames() {
    pgrep --list-name "$@" | catOrLess
}
alias pgrep1='pgrepWithNames'

# Sends KILL signal to process with specified PID, instead of
# kill's default signal TERM.
killWithKillSignal() {
    kill -9 "$@"
}
alias kill1='killWithKillSignal'

# Traces system calls and signals. Prints strings of maximum
# 2000 characters, and also traces child processes.
straceAlsoChildren() {
    strace -s 2000 -f "$@" 2>&1 | catOrLess
}
alias strace1='straceAlsoChildren'
alias st='straceAlsoChildren'


########
# TEXT #
########

# Deletes specified characters.
alias trd='tr --delete'


##########
# TABLES #
##########

# Creates table out of input lines (lines up the columns). You
# need to specify the delimiter character with first argument.
alias table='column -t -s'

# Treats input lines as rows of a table. With second argument
# you specify the columns you want to retain, and with first,
# the delimiter character. For more columns use comma or dash
# (for ranges).
keepColumns() {
    cut --delimiter="$1" --fields="$2" 
}
alias cut1='keepColumns'

# Treats input lines as rows of a table and sorts them by column
# you specify with second parameter. First argument specifies
# the delimiter character. Using comma, more columns can be
# specified (in order of importance).
sortByColumn() { 
    sort --field-separator="$1" --key="$2"
}
alias sort1='sortByColumn'


##########
# SEARCH #
##########

# Runs grep with highlighting matches and not grepping through
# .svn and .git folders.
#grepWithSensibleOptions() {
#       grep --color=auto --exclude-dir=\.svn \
#    --exclude-dir=\.git "$@"
#}

# Runs grep in perl regex mode (that has some additional operators, like '+' for matching one or more times), ignoring case, with highlighting matches, not grepping through .svn and .git folders and sends output to pager.
#grepPerl() {
#    grepWithSensibleOptions --ignore-case --perl-regexp --color=always "$@" \
#        | catOrLess
#}
#alias gr='grepPerl'

# Runs grep with highlighting matches, not grepping through .svn
# and .git folders, using perl reges format (it has some
# additional operators, for instance, '+' for matching one or
# more times), ignoring case and it sends output to pager.
grepWithSensibleOptions() {
    grep --exclude-dir=\.svn --exclude-dir=\.git \
        --ignore-case --perl-regexp --color=always "$@" \
        | catOrLess
}
alias grep1='grepWithSensibleOptions'
alias gr='grepWithSensibleOptions'

# Tries to find specified file using index. (Run 'sudo updatedb'
# to update the index)
locateWithPager() {
    locate "$@" | catOrLess
}
alias locate1='locateWithPager'

# Searches for files containing pattern in their names in
# current and sub-directories.  Use filesystem regexes for
# search (aka *.*), and always surround them with quotation
# marks. Also highlights the matches.
findWithHighlight() {
    find . -name "$1" | grepWithSensibleOptions $(echo "$1" | tr -d "\*")
}
find1='findWithHighlight'

# Prints all directories in current and sub-directories.
printAllDirectoriesBelove() {
	find . -name .git -prune -o -type d | catOrLess
}
alias findd=printAllDirectoriesBelove


############
# ARCHIVES #
############

# Extracts archive of any type. (Author (Vitalii
# Tereshchuk)[https://github.com/xvoland])
extractArchiveOfAnyType() {
    if [ -z "$1" ]; then
        # display usage if no parameters given
        echo -n "Usage: extract <path/file_name>"
        echo -n ".<zip|rar|bz2|gz|tar|tbz2|tgz|Z|"
        echo "7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
    else
        if [ -f "$1" ] ; then
            NAME=${1%.*}
            #mkdir $NAME && cd $NAME
            case "$1" in
                *.tar.bz2)   tar xvjf ./"$1"    ;;
                *.tar.gz)    tar xvzf ./"$1"    ;;
                *.tar.xz)    tar xvJf ./"$1"    ;;
                *.lzma)      unlzma ./"$1"      ;;
                *.bz2)       bunzip2 ./"$1"     ;;
                *.rar)       unrar x -ad ./"$1" ;;
                *.gz)        gunzip ./"$1"      ;;
                *.tar)       tar xvf ./"$1"     ;;
                *.tbz2)      tar xvjf ./"$1"    ;;
                *.tgz)       tar xvzf ./"$1"    ;;
                *.zip)       unzip ./"$1"       ;;
                *.Z)         uncompress ./"$1"  ;;
                *.7z)        7z x ./"$1"        ;;
                *.xz)        unxz ./"$1"        ;;
                *.exe)       cabextract ./"$1"  ;;
                *)           echo "extract: '$1' - unknown archive method" ;;
            esac
        else
            echo "'$1' - file does not exist"
        fi
    fi
}
alias extract='extractArchiveOfAnyType'


########
# TMUX #
########

# Runs Tmux.
alias tm='tmux'

# Runs Tmux, and attaches to last session.
alias tma='tmux attach'

# Lists all running Tmux sessions.
alias tml='tmux ls'


######################
# SYSTEM INFORMATION #
######################

# Reports disk space of main partitions in human readable form.
diskSpaceUsageSimplified() {
    df -h | grep "sd\|Size" | cat
}
alias df1='diskSpaceUsageSimplified'

# Displays disk space used by a folder or a file in human
# readable form.
alias du1='du --summarize --human-readable'

# Prints all and free memory in megabytes.
freeAndAllMemory() {
    echo "all: "$(free -m \
        | grep Mem \
        | sed 's/^Mem: *\([0-9]*\).*/\1/')" MB"
    echo "free: "$(free -m \
        | grep Mem \
        | sed 's/^[^ ]*[ ]*[^ ]*[ ]*[^ ]*[ ]*\([^ \
]*\)[ ]*[^ ]*[ ]*[^ ]*[ ]*[^ ]*/\1/')" MB"
}
alias free1='freeAndAllMemory'
alias fr='freeAndAllMemory'

# Displays CPU's temperature.
cpusTemperature() {
    acpi -t
}
alias temperature='cpusTemperature'
alias temp='cpusTemperature'

# Prints battery status.
batteryStatus() {
    acpi
}
alias battery='batteryStatus'
alias batt='batteryStatus'

# Prints kernel version and Linux distribution.
alias uname1='uname --all'

# Prints verbose information about all PCI devices.
alias lspci1='lspci -v | catOrLess'


#########
# POWER #
#########

# Restarts computer.
alias restart='sudo shutdown -r now'

# Shuts down computer.
alias poweroff='sudo shutdown now'

# Hibernates.
alias hib='sudo pm-hibernate'

# Suspends.
alias sus='sudo pm-suspend'


############
# KEYBOARD #
############

# Sets keyboard layout to us layout.
alias uskeys='setxkbmap -layout us'

# Gets keycode of pressed key.
alias keycode='xev'

# Turns key input repeat off.
alias norepeat='xset -r'

# Turns key input repeat on.
alias repeat='xset r'


########
# MISC #
########

# Changes the hue of default blue color in Linux terminal (tty),
# that is otherwise hard to read.
alias blue='echo -en "\e]PC7373C9"'

# Prints PATH variable, each entry in its own line.
alias path='echo -e ${PATH//:/\\n}'

# Runs console calculator with decimal numbers.
alias bc1='gcalccmd'

# Prints hexadecimal representation of file or piped stream.
hdWithPager() {
    hd "$@" | catOrLess
}
alias hd1='hdWithPager'

# Trims SSD disk.
trimSsd() {
	sudo fstrim -v /
}
alias ssd='trimSsd'

# Sets bash to vi mode.
alias vimode='set -o vi'

# Sets bash to emacs (normal) mode.
alias emacsmode='set -o emacs'

# Runs profile script.
alias profile='source /etc/profile'

# Runs a typing tutor.
alias tt='gtypist'

# Counts number of lines in files with specified extension 
# in current and sub-directories.
linesOfCode() {
    rootDir="$PWD"
    no=0
    for file in *; do
        if [ -d "$file" ]; then
            #echo "entering $file" >&2
            cd "$file"
            recRes=`linesOfCode "$1"`
            #echo "recRes is $recRes" >&2
            let no=$no+"$recRes"
            cd "$rootDir"
        fi
        if [[ "$file" == *."$1" ]]; then
            let no=$no+`cat "$file" | wc -l`    
        fi
    done
    echo $no
}
alias loc='linesOfCode'


############
# PACKAGES #
############

# Installs package.
alias canhaz='sudo apt-get install'
alias ch='canhaz'

# Updates package information.
alias update='sudo apt-get update'

# Upgrades all packages to newest available version.
alias upgrade='sudo apt-get upgrade'

# Tries to upgrade all packages. If any dependency conflicts
# arise, then it handles them intelligently, by upgrading the
# most important packages at the expense of less important ones.
alias dist-upgrade='sudo apt-get dist-upgrade'

# Removes package and all the packages this package dependent on
# and were only used by this package.
alias remove='sudo apt-get remove && autoremove'

# Removes package, together with its configuration files. All
# the packages this package dependent on and were only used by
# this package are also removed.
alias purge='sudo apt-get purge && autoremove'

# Removes packages that were automatically installed to satisfy
# dependencies for other packages and are now no longer needed.
alias autoremove='sudo apt-get autoremove'

# Prints installed and remote version of package.
alias version='apt-cache policy'
alias ve='version'

# Prints packages that were installed by the user, in order of
# installation.
installedPackagesByUser() {
    cat /var/log/apt/history.log \
        | grep "apt-get install" \
        | sed "s/.* //" \
        | catOrLessG'
}
alias packages='installedPackagesByUser'
alias installed='installedPackagesByUser' 

# Prints all installed packages.
installedPackages() {
    dpkg --get-selections \
        | grep -v deinstall \
        | catOrLess'
}
alias packages1='installedPackages'
alias installed1='installedPackages'

# Shows on which packages specified package depends.
packageDependsOn() {
    apt-cache show "$@" \
        | grep Depends \
        | sed 's/Depends:/ /' \
        | sed 's/,/\n /g' \
        | catOrLess
}
alias depends='packageDependsOn'


##########################
# PACKAGE/COMMAND SEARCH #
##########################

# Runs apropos, that searches installed commands, by their names
# and short descriptions. Matches get highlighted.
aproposWithHighlight() {
    apropos "$@" | grepWithSensibleOptions  "$@"
}
alias apropos1='aproposWithHighlight'
alias ap='aproposWithHighlight'

# Searches packages, that can be installed with apt-get. Search
# is performed on their names and short descriptions.
searchInstallablePackagesAndTheirDescriptions() {
    apt-cache search "$@" | grepWithSensibleOptions  "$@"
}
alias search='searchInstallablePackagesAndTheirDescriptions'

# Searches packages, that can be installed with apt-get. Search
# is performed only on their names.
searchInstallablePackages() {
    apt-cache search "$@" | grepWithSensibleOptions "^[^ ]*$@[^ ]*" 
}
alias search1='searchInstallablePackages'

#######################################

# TODO from here to end of section

# Searches packages based on their name and also by their
# executables
y() {
    (echo   "PACKAGES CONTAINING EXECUTABLES NAMED \"$1\""
    echo -n "========================================"
    echo "$1" | sed 's/./=/g'
    apt-file1 "$@" | grepWithSensibleOptions "^.*:"
    echo -e "\nPACKAGES CONTAINING \"$@\" IN THEIR NAMES"   
    echo -n   "====================================="
    echo "$1" | sed 's/./=/g'
    searchInstallablePackages "$@") | lessWithSensibleOptions 
}

# Find to which of the installed packages passed command belongs
# to
package() {
    file=$(sudo which "$1")
    if [ "$file" == "" ]; then 
        return
    fi  
    resolved=$(readlink -f "$file")
    dpkg -S "$resolved" 
}

# Find to which of all the packages the command belongs to
apt-file1() {
    apt-file search "$1" | grep \/"$1"$ | catOrLess 
}

alias wi1='whatis'
# Prints package description. (Few lines)
whatis2() {
    apt-cache show "$*" | grep "^ " | catOrLess
}
alias wi2='whatis2'

# Searches aliases for name
whatis3() {
    type "$*" | catOrLess
}
alias wi3='whatis3'

# Searches all packages for file
whatis4() {
    package "$@"
}
alias wi4='whatis4'

# Searches all packages for file
whatis5() {
    apt-file1 "$@"
}
alias wi5='whatis5'

# Searches all packages for keyword 
whatis6() {
    search "$@"
}
alias wi6='whatis6'

# Converts man section number to a description
manSection() {
    case "$1" in
        1)
            echo "user command"
            ;;
        2)
            echo "system call"
            ;;
        3)
            echo "c function"
            ;;
        4)
            echo "device file"
            ;;
        5)
            echo "file format or convention"
            ;;
        6)
            echo "game"
            ;; 
        7)
            echo "miscallaneous"
            ;;
        8)
            echo "su command"
            ;;
        9)
            echo "kernel routine"
            ;;
    esac
}

# Universal command description search function. First tries
# whatis, then apt-cache show, then type and finally apt-file.
# When one of them succeeds in finding the description the
# function returns.
whatIs() {
    call1=`whatis "$@" 2> /dev/null`
    if [ "$?" == "0" ]; then
        while IFS= read -r line; do
            commandType=$(
                manSection $(
                    echo "$line" | sed 's/.*(\([1-9]\)).*/\1/'
                )
            )
            echo "$line" "($commandType)"
        done <<< "$call1"
        echo -n "package: "
        package "$@" | sed 's/:/\nlocation:/'
        return
    fi

    call2=`apt-cache show "$*" 2> /dev/null | grep "^ "`
    if [ "$?" == "0" ]; then
        echo "$call2" | catOrLess
        return
    fi

    call3=`type "$*" 2> /dev/null`
    if [ "$?" == "0" ]; then
        echo "$call3"
        return
    fi

    call4=`package "$@"`
    if [ "$call4" != "" ]; then
        echo "$call4"
        return
    fi

    call5=`apt-file1 "$@" | grepWithSensibleOptions "^.*:"`
    if [ "$call5" != "" ]; then
        echo -n "You need to install one of the following packages"
        echo -e " to get the command:\n$call5" | catOrLess
    fi

    call6=`search "$@"`
    if [ "$call6" != "" ]; then
        echo  "$call6" | catOrLess
    fi
}
alias wi='whatIs'


#######
# GIT #
#######

# Commits changed and deleted files. Commit message must be
# entered as parameter.
alias commit='git commit -am'

# Commits changed and deleted files. Opens text editor, so
# proper commit message can be entered.
alias commitm='git commit -a'

# Creates an empty Git repository or reinitializes an existing
# one.
alias init='git init'

# Pushes changes to remote repository.
alias push='git push'

# Pulls changes from remote repository.
alias pull='git pull'

# Joins specified branch with current one.
alias merge='git merge'

# Switches to another branch, or checks-out a file from
# repository.
alias checkout='git checkout'
alias gc='checkout'

# Prints all branches, or creates new one, if name is specified. 
alias branch='git branch'
alias gb='branch'

# Prints short status of repository.
shortGitStatus() {
    git -c color.status=always status -sb | catOrLess
}
alias gs='shortGitStatus'

# Prints nicely decorated graph of commits, with commit
# messages, full hashes and full dates. 
fullGitLogWithGraph() {
    git log --decorate --graph --all
}
alias gl='fullGitLogWithGraph'

# Prints nicely decorated graph of commits, with only first
# lines of commit messages, shortened hashes and full dates.
minimalGitLogWithGraph() {
    git log --graph --abbrev-commit --decorate \
        --format=format:'%C(bold blue)%h%C(reset) \
        - %C(bold cyan)%aD%C(reset) \
        %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n'' \
        %C(white)%s%C(reset) %C(dim white)- %an%C(reset)' --all
}
alias gl1='minimalGitLogWithGraph'

# Updates information about state of the remote repository and
# prints status.
gitRemoteUpdateAndPrintStatus() {
    git remote update
    shortGitStatus
}
alias gu='gitRemoteUpdateAndPrintStatus'

# Shows changes between commits. If no parameter is given, then
# shows changes between last commit and current state.
alias gd='git diff'

# Adds file to repository.
alias ga='git add'

# Moves file or directory. Git will in most cases recognize that
# files were moved even if regular 'mv' command was used, but
# this way it is for shure.
alias gm='git mv'

# Prints files that are in repository.
alias lsgit='git ls-files'
alias gls='lsgit'


##########
# GITHUB #
##########

# Clones project from Github. User and project names must be
# specified as <user>/<project>.
cloneGithubProject() {
    git clone git@github.com:/"$1".git
}
alias clone='cloneGithubProject'

# Sets remote repository to specified Github project. Repository
# must be entered as <user>/<project>.
setGithubOrigin() {
    git remote add origin git@github.com:/"$1".git
    git pull origin master
    git push origin master
}
alias origin='setGithubOrigin'

# Clones all users Github projects in working directory.
cloneAllUsersGithubProjects() {
    if [[ -z "$1" ]]; then
        exit
    fi
    tempFile=`mktemp`
    wget 'https://github.com/gto76?tab=repositories' -O "$tempFile"
    repos=$(grep "$1"/[^//\"]* -o "$tempFile" \
        | sort -u \
        | grep -v follow)
    while read -r line; do
        git clone git@github.com:"$line"
    done <<< "$repos"
}
alias cloneAll='cloneAllUsersGithubProjects'


###########
# NETWORK #
###########

# Prints internal ip.
internalIp() {
    /sbin/ifconfig \
        | grep "inet addr:192.168" \
        | grep -o addr:[0-9.]* \
        | grep -o [0-9.]\* \
        | cat 
}
alias ip1='internalIp'

# Prints external ip. 
externalIp() {
    lynx --dump http://ipecho.net/plain | grep -o [0-9.]\*
}
alias ip2='externalIp'

# Prints gateways ip.
alias gateway='route -n | grep "192.168." | head -n1 \
    | grep -o "192.168.[0-9.]*"'

# Prints mac addresses of local devices.
alias mac='ifconfig | grep HWaddr | cat'

# Pings gateway, ip address of noip.com and www.google.com.
pingGatewayIpAndGoogle() {
    ping -c 1 -q `gateway` | grep --color=never -A 1 statistics
    ping -c 1 -q 8.23.224.107 | grep --color=never -A 1 statistics
    ping -c 1 -q www.google.com | grep --color=never -A 1 statistics
}
alias pingAll='pingGatewayIpAndGoogle'
alias pa='pingGatewayIpAndGoogle'

# Scans addresses of local network. If a number is specified it scans local addresses up to this number (0-255).
scanLocalNetwork() {
    if [[ $# -eq 0 ]]; then
        third=$(ip1 \
            | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta')
        forth="254"
    fi
    if [[ $# -eq 1 ]]; then
        third=$(ip1 \
            | sed -e :a -e 's/[0-9]*.\([0-9]\).[0-9]*.[0.9]*/\1/;ta')
        forth="$1"
    fi
    if [[ $# -gt 1 ]]; then
        third="$1"
        forth="$2"
    fi
    nmap -sP 192.168."$third".0-"$forth"
}
alias nmap1='scanLocalNetwork'

# Prints 'OK' if specified address or ip can be reached with ping, or 'Fail' if not.
isReachable() {
    pingResult=$(
        ping -c 1 -q "$1" \
            | grep --color=never -A 1 statistics \
            | grep "1 received")
    if [ "$pingResult" != "" ]; then
        echo -n "OK"
    else
        echo -n "Fail"
    fi
}

# Prints status of the ssh port of the specified client.
port22status() {
    nmap $(echo "$1" | tr -d ' ') -p22 \
        | grep '22/tcp' \
        | sed 's/^[^ ]* \([^ ]*\) .*$/\1/'
}

# Scans first 20 addresses of local network and prints yours,
# gateways and the ip-s of other connected devices. Also checks
# their ssh port status.  After that checks checks if connection
# to the internet is available by pinging Google and ip address
# of noip.com.
networkStatus() {
    localIp=$(ip1)
    gateway=$(gateway)
    echo "You:      $localIp   ssh: $(port22status $(ip2))"
    echo "Gateway:  $gateway    ssh: $(port22status "$gateway")"
    all=$(nmap1 20)
    allFiltered=$(
        echo "$all" | 
        grep -v "$localIp" |
        grep -v "$gateway" |
        grep -o "[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*" |
        sed 's/^/          /g' ) 
    len=${#allFiltered} 
    allFiltered=${allFiltered:6:len-6} 
    echo -n "Other:"

    while IFS= read -r line; do 
        echo -n "$line    ssh: "
        port22status "$line"    
    done <<< "$allFiltered"

    testIp="8.23.224.107"
    echo "Internet: $testIp   Ping: $(isReachable "$testIp")"
    testDomain="www.google.com"
    echo "          $testDomain Ping: $(isReachable "$testDomain")"
}
alias network='networkStatus'
alias ne='networkStatus'


############
# WIRELESS #
############

# Disables wireless device.
blockWirelessDevice() {
    sudo rfkill block $(
        sudo rfkill list \
            | grep Wireless \
            | grep ^[0-9] -o)
}
alias woff='blockWirelessDevice'

# Enables wireless device.
unblockWirelessDevice() {
    sudo rfkill unblock $(
        sudo rfkill list \
            | grep Wireless \
            | grep ^[0-9] -o)
}
alias won='unblockWirelessDevice'

# Resets wireless device.
resetWirelessDevice() {
    woff
    won
}
alias wr='resetWirelessDevice'

# Activates wireless interface (driver).
activateWirelessInterface() {
    sudo ifconfig wlan0 up
}
alias up='activateWirelessInterface'

# Shuts down wireless interface (driver).
deactivateWirelessInterface() {
    sudo ifconfig wlan0 down
}
alias down='deactivateWirelessInterface'

# Displays wireless networks in range.
wirelessNetworksInRange() {
    sudo iwlist wlan0 scan \
        | grep Quality -A2 \
        | tr -d "\n" \
        | sed 's/--/\n/g' \
        | sed -e 's/ \+/ /g' \
        | sort -r \
        | sed 's/ Quality=//g' \
        | sed 's/\/70 Signal level=-[0-9]* dBm Encryption key:/ /g' \
        | sed 's/ ESSID:/ /g'
}
alias wlan='wirelessNetworksInRange'


############
# INTERNET #
############

# Runs default browser in background.
defaultBrowserInBackground() {
    runInBackground sensible-browser "$@"
}
alias internet='defaultBrowserInBackground'
alias i='defaultBrowserInBackground'

# Runs Firefox in background.
firefoxInBackground() {
    runInBackground firefox "$@"
}
alias fire='firefoxInBackground'

# Runs Chrome in background with setting that resolves some bug
# in some cases (it is probably already fixed).
chromeInBackground() {
    runInBackground google-chrome --touch-devices=123
}
alias chrome='chromeInBackground'

# Runs Lynx that accepts all cookies, starts in Google and is
# using Vim mode for navigation.
lynxWithSensibleOptions() {
    lynx -accept_all_cookies -vikeys www.google.com "$@"
}
alias lynx1='lynxWithSensibleOptions'


#########
# AUDIO #
#########

# Control volume of all audio channels.
alias mixer='alsamixer'

# Set master volume in rage of 0 to 100.
setVolume() {
    amixer set Master playback "$1"
}

# Increases volume by 6dB.
volumeUp6Db() {
    setVolume "6%+" | tail -n 1
}
alias a='volumeUp6Db'

# Decreases volume by 6dB.
volumeDown6Db() {
    setVolume "6%-" | tail -n 1
}
alias z='volumeDown6Db'

# Increases volume by 2dB.
volumeUp2Db() {
    setVolume "2%+" | tail -n 1
}
alias aa='volumeUp2Db'

# Decreases volume by 2dB.
volumeDown2Db() {
    setVolume "2%-" | tail -n 1
}
alias zz='volumeDown2Db'

